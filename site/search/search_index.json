{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sentinel MCP Documentation Welcome to the comprehensive documentation for Sentinel MCP\u2014your guide to building secure, governable AI agent systems. \u26a0\ufe0f Important: This is a personal R&D project \u2013 an exploration of governance patterns for AI agents. This is not a commercial product and I am not seeking to develop this into a product . The documentation is shared for learning, research, and community discussion. \ud83c\udfaf What Is Sentinel MCP? Sentinel MCP is a control plane for AI agents that brings enterprise-grade governance to autonomous systems. In an era where AI agents can autonomously use tools, access APIs, and make decisions, Sentinel MCP ensures you maintain control, visibility, and compliance. Project Nature: This is a personal research and development project, born from passion for AI governance and continuous exploration of how to make autonomous systems safer and more controllable. Think of it as: - \ud83d\udee1\ufe0f A security guard checking every tool access request - \ud83c\udf9b\ufe0f A control panel managing your entire AI tool ecosystem - \ud83d\udccb An audit trail proving compliance and accountability - \ud83d\udea8 An emergency stop button for instant tool disabling \ud83c\udf0d Why This Matters Today The AI landscape has fundamentally changed. In 2024, we're witnessing the rapid adoption of: - Autonomous AI agents that can use tools without human approval - Model-Context Protocol (MCP) enabling dynamic tool discovery - Multi-agent systems orchestrating complex workflows But traditional security models break down: - \u274c You can't \"train\" agents like employees - \u274c Agent behavior is unpredictable and scales instantly - \u274c Compliance requires cryptographic proof, not just logs - \u274c Incidents require sub-second response, not manual intervention Sentinel MCP addresses these challenges by providing runtime governance that sits between agents and tools, enforcing policies, tracking provenance, and enabling instant control. \ud83d\udcda Documentation Guide For Executives & Business Leaders Start here: Executive Brief Understanding the business value, risk mitigation, and adoption strategy. Learn why governance for AI agents isn't optional\u2014it's essential for production deployments. Then explore: - Policy Playbook \u2013 How policies protect your organization - FAQ \u2013 Common questions answered For Engineers & Developers Start here: Architecture Deep Dive Deep technical dive into system design, components, and data flows. Understand how Sentinel MCP integrates with your stack. Then explore: - Setup & Deployment \u2013 Get up and running - Testing Strategy \u2013 Quality assurance approach - Runbooks \u2013 Operational procedures For Security & Operations Teams Start here: Security & Compliance Threat model, security controls, and hardening recommendations. Learn how Sentinel MCP protects your AI infrastructure. Then explore: - Runbooks \u2013 Troubleshooting and incident response - Policy Playbook \u2013 Writing effective policies For Everyone Quick references: - Glossary \u2013 Terms and definitions - FAQ \u2013 Answers to common questions \ud83d\ude80 Quick Navigation I want to... Go to... Understand the business case Executive Brief See how it works technically Architecture Get started quickly Setup Guide Write policies Policy Playbook Troubleshoot issues Runbooks Secure the system Security Guide Understand a term Glossary \ud83c\udf93 Key Concepts The Control Plane Model Sentinel MCP follows a control plane architecture \u2014a centralized system that manages policy enforcement, tool inventory, and audit logging. All agent-to-tool interactions flow through the control plane, ensuring consistent governance. Policy-as-Code Policies are written in Rego (Open Policy Agent's language) and stored as code. This enables: - Version control and collaboration - Automated testing - GitOps-style deployment - Consistency across environments Provenance & Auditability Every action generates a provenance manifest \u2014a cryptographically signed record proving: - What action was taken - Who (which agent/tenant) took it - When it occurred - Whether it was authorized This provides non-repudiation \u2014you can prove compliance and accountability. Kill Switch Capability In emergencies, the kill switch can: - Instantly disable tools system-wide - Revoke credentials via adapter hooks - Prevent further tool invocations - Generate audit events Target MTTR: < 5 seconds from incident detection to tool disablement. \ud83c\udfd7\ufe0f How It Works (High Level) Registration \u2013 Tools register with the control plane, declaring capabilities and metadata Policy Check \u2013 Before each tool use, agents request authorization Evaluation \u2013 Policy engine evaluates request against rules (identity, quota, purpose) Decision \u2013 Allow or deny based on policy Provenance \u2013 If allowed, action is cryptographically signed Audit \u2013 All decisions logged for compliance \ud83d\udcca Real-World Scenarios Scenario 1: Budget Protection - Agent requests expensive API call - Policy checks quota \u2192 over limit - Request denied with clear reason - FinOps team notified automatically Scenario 2: Security Incident - Suspicious activity detected - Security team triggers kill switch - Tool disabled system-wide in < 5 seconds - All agents immediately blocked from using tool - Investigation begins with full audit trail Scenario 3: Compliance Audit - Auditor requests proof of actions - Provenance manifests retrieved - Cryptographic signatures verified - Complete audit trail provided showing authorized actions only \ud83c\udfaf What's Next? New to Sentinel MCP? \u2192 Start with Executive Brief Ready to deploy? \u2192 Follow Setup Guide Need to write policies? \u2192 Read Policy Playbook Troubleshooting? \u2192 Check Runbooks \ud83d\udcec Get Help Questions? Check the FAQ Found a bug? Open an issue on GitHub Want to contribute? See CONTRIBUTING.md Remember: Sentinel MCP isn't just about preventing bad things\u2014it's about enabling confident, compliant AI agent deployments. With proper governance, you can safely unleash the power of autonomous agents while maintaining control.","title":"Overview"},{"location":"#sentinel-mcp-documentation","text":"Welcome to the comprehensive documentation for Sentinel MCP\u2014your guide to building secure, governable AI agent systems. \u26a0\ufe0f Important: This is a personal R&D project \u2013 an exploration of governance patterns for AI agents. This is not a commercial product and I am not seeking to develop this into a product . The documentation is shared for learning, research, and community discussion.","title":"Sentinel MCP Documentation"},{"location":"#what-is-sentinel-mcp","text":"Sentinel MCP is a control plane for AI agents that brings enterprise-grade governance to autonomous systems. In an era where AI agents can autonomously use tools, access APIs, and make decisions, Sentinel MCP ensures you maintain control, visibility, and compliance. Project Nature: This is a personal research and development project, born from passion for AI governance and continuous exploration of how to make autonomous systems safer and more controllable. Think of it as: - \ud83d\udee1\ufe0f A security guard checking every tool access request - \ud83c\udf9b\ufe0f A control panel managing your entire AI tool ecosystem - \ud83d\udccb An audit trail proving compliance and accountability - \ud83d\udea8 An emergency stop button for instant tool disabling","title":"\ud83c\udfaf What Is Sentinel MCP?"},{"location":"#why-this-matters-today","text":"The AI landscape has fundamentally changed. In 2024, we're witnessing the rapid adoption of: - Autonomous AI agents that can use tools without human approval - Model-Context Protocol (MCP) enabling dynamic tool discovery - Multi-agent systems orchestrating complex workflows But traditional security models break down: - \u274c You can't \"train\" agents like employees - \u274c Agent behavior is unpredictable and scales instantly - \u274c Compliance requires cryptographic proof, not just logs - \u274c Incidents require sub-second response, not manual intervention Sentinel MCP addresses these challenges by providing runtime governance that sits between agents and tools, enforcing policies, tracking provenance, and enabling instant control.","title":"\ud83c\udf0d Why This Matters Today"},{"location":"#documentation-guide","text":"","title":"\ud83d\udcda Documentation Guide"},{"location":"#for-executives-business-leaders","text":"Start here: Executive Brief Understanding the business value, risk mitigation, and adoption strategy. Learn why governance for AI agents isn't optional\u2014it's essential for production deployments. Then explore: - Policy Playbook \u2013 How policies protect your organization - FAQ \u2013 Common questions answered","title":"For Executives &amp; Business Leaders"},{"location":"#for-engineers-developers","text":"Start here: Architecture Deep Dive Deep technical dive into system design, components, and data flows. Understand how Sentinel MCP integrates with your stack. Then explore: - Setup & Deployment \u2013 Get up and running - Testing Strategy \u2013 Quality assurance approach - Runbooks \u2013 Operational procedures","title":"For Engineers &amp; Developers"},{"location":"#for-security-operations-teams","text":"Start here: Security & Compliance Threat model, security controls, and hardening recommendations. Learn how Sentinel MCP protects your AI infrastructure. Then explore: - Runbooks \u2013 Troubleshooting and incident response - Policy Playbook \u2013 Writing effective policies","title":"For Security &amp; Operations Teams"},{"location":"#for-everyone","text":"Quick references: - Glossary \u2013 Terms and definitions - FAQ \u2013 Answers to common questions","title":"For Everyone"},{"location":"#quick-navigation","text":"I want to... Go to... Understand the business case Executive Brief See how it works technically Architecture Get started quickly Setup Guide Write policies Policy Playbook Troubleshoot issues Runbooks Secure the system Security Guide Understand a term Glossary","title":"\ud83d\ude80 Quick Navigation"},{"location":"#key-concepts","text":"","title":"\ud83c\udf93 Key Concepts"},{"location":"#the-control-plane-model","text":"Sentinel MCP follows a control plane architecture \u2014a centralized system that manages policy enforcement, tool inventory, and audit logging. All agent-to-tool interactions flow through the control plane, ensuring consistent governance.","title":"The Control Plane Model"},{"location":"#policy-as-code","text":"Policies are written in Rego (Open Policy Agent's language) and stored as code. This enables: - Version control and collaboration - Automated testing - GitOps-style deployment - Consistency across environments","title":"Policy-as-Code"},{"location":"#provenance-auditability","text":"Every action generates a provenance manifest \u2014a cryptographically signed record proving: - What action was taken - Who (which agent/tenant) took it - When it occurred - Whether it was authorized This provides non-repudiation \u2014you can prove compliance and accountability.","title":"Provenance &amp; Auditability"},{"location":"#kill-switch-capability","text":"In emergencies, the kill switch can: - Instantly disable tools system-wide - Revoke credentials via adapter hooks - Prevent further tool invocations - Generate audit events Target MTTR: < 5 seconds from incident detection to tool disablement.","title":"Kill Switch Capability"},{"location":"#how-it-works-high-level","text":"Registration \u2013 Tools register with the control plane, declaring capabilities and metadata Policy Check \u2013 Before each tool use, agents request authorization Evaluation \u2013 Policy engine evaluates request against rules (identity, quota, purpose) Decision \u2013 Allow or deny based on policy Provenance \u2013 If allowed, action is cryptographically signed Audit \u2013 All decisions logged for compliance","title":"\ud83c\udfd7\ufe0f How It Works (High Level)"},{"location":"#real-world-scenarios","text":"Scenario 1: Budget Protection - Agent requests expensive API call - Policy checks quota \u2192 over limit - Request denied with clear reason - FinOps team notified automatically Scenario 2: Security Incident - Suspicious activity detected - Security team triggers kill switch - Tool disabled system-wide in < 5 seconds - All agents immediately blocked from using tool - Investigation begins with full audit trail Scenario 3: Compliance Audit - Auditor requests proof of actions - Provenance manifests retrieved - Cryptographic signatures verified - Complete audit trail provided showing authorized actions only","title":"\ud83d\udcca Real-World Scenarios"},{"location":"#whats-next","text":"New to Sentinel MCP? \u2192 Start with Executive Brief Ready to deploy? \u2192 Follow Setup Guide Need to write policies? \u2192 Read Policy Playbook Troubleshooting? \u2192 Check Runbooks","title":"\ud83c\udfaf What's Next?"},{"location":"#get-help","text":"Questions? Check the FAQ Found a bug? Open an issue on GitHub Want to contribute? See CONTRIBUTING.md Remember: Sentinel MCP isn't just about preventing bad things\u2014it's about enabling confident, compliant AI agent deployments. With proper governance, you can safely unleash the power of autonomous agents while maintaining control.","title":"\ud83d\udcec Get Help"},{"location":"appendix/faq/","text":"Frequently Asked Questions Project Status Is this a commercial product? No. This is a personal R&D exploration project , not a commercial product. I am not seeking to develop this into a product or commercialize it. This project represents my passion for AI governance and continuous exploration of how to make autonomous systems safer and more controllable. It's shared openly for learning, research, and community discussion. What's the purpose of this project? This project is an exploration of governance patterns for AI agents\u2014born from curiosity, passion, and continuous learning. The goal is to advance understanding of how to govern autonomous systems, share ideas with the community, and contribute to the broader conversation about AI agent safety and controllability. General Questions What is Sentinel MCP? Sentinel MCP is a control plane for AI agents that provides governance, security, and compliance for autonomous systems. It sits between AI agents and the tools they want to use, enforcing policies, tracking provenance, and enabling instant control through kill switches. Think of it as: A security guard, budget manager, and compliance auditor all rolled into one system, specifically designed for AI agents. Is Sentinel MCP production-ready? Status: \ud83e\uddea R&D Prototype \u2013 Active development What's working: - \u2705 Core control plane functionality - \u2705 Policy engine integration - \u2705 Kill switch capability - \u2705 Provenance signing - \u2705 Multi-framework adapters - \u2705 Admin console What needs work for production: - \ud83d\udd04 Authentication/authorization (currently open) - \ud83d\udd04 Production-grade secrets management - \ud83d\udd04 Sigstore integration for provenance - \ud83d\udd04 Enhanced observability - \ud83d\udd04 Performance optimization Recommendation: Use for R&D, pilot projects, and learning. For production deployments, plan for additional hardening (see Security Guide ). How does Sentinel MCP differ from API gateways? API gateways are designed for human users and traditional applications. Sentinel MCP is designed specifically for AI agents with unique challenges: Feature API Gateway Sentinel MCP Designed for Human users, traditional apps AI agents Policy evaluation Basic auth/rate limiting Rich context-aware policies Provenance Logs only Cryptographic signatures Kill switch Manual or complex Instant, system-wide Agent awareness No Yes (framework adapters) Key difference: Sentinel MCP understands that agents are autonomous, unpredictable, and need runtime governance. Can I use SQLite instead of PostgreSQL? Not currently. The schema relies on PostgreSQL-specific features: - JSONB for flexible metadata storage - Advanced indexing for performance - ACID compliance for audit logs For testing: Consider using PostgreSQL in Docker for local development. Future: Could add SQLite support for testing, but PostgreSQL is recommended for any real usage. Real-World Scenarios Scenario: \"An agent is making too many API calls and exceeding our budget\" Problem: Your AI agent is calling an expensive API repeatedly, running up costs. Solution: 1. Define a quota policy: rego quota := data.quotas[input.tenant][input.tool] input.usage < quota Set quotas in OPA data: json { \"quotas\": { \"platform-eng\": { \"openai-gpt4\": 1000 } } } Result: When quota is exceeded, requests are denied with clear messaging. Business value: Prevents budget overruns automatically, no manual intervention needed. Scenario: \"We need to prove compliance during an audit\" Problem: Auditor asks: \"Can you prove which actions were authorized?\" Solution: 1. Every action generates a provenance manifest: json { \"id\": \"manifest-123\", \"tenant\": \"platform-eng\", \"tool\": \"customer-api\", \"action\": \"invoke\", \"authorized\": true, \"signature\": \"...\", \"timestamp\": \"2024-01-15T10:30:00Z\" } Manifests are cryptographically signed (non-repudiation) Export manifests for audit window: bash # Query database for manifests in date range SELECT * FROM provenance_manifests WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31' Business value: Pass compliance audits with cryptographic proof, not just logs. Scenario: \"A security incident requires immediately disabling a tool\" Problem: Security team detects suspicious activity. Need to block tool access NOW. Solution: 1. Trigger kill switch: bash curl -X POST http://control-plane:8000/kill \\ -H \"Content-Type: application/json\" \\ -d '{\"tenant\": \"platform-eng\", \"tool\": \"compromised-tool\"}' What happens: Tool marked as is_active = false in database (< 100ms) Adapters notified via hooks (< 1s) All future policy checks deny immediately Audit log entry created Target MTTR: < 5 seconds from incident to tool disablement Business value: Respond to incidents instantly, reducing breach impact. Scenario: \"Teams are deploying agents without coordination\" Problem: Shadow IT\u2014teams deploying agents and tools without central oversight. Solution: 1. Register all tools: bash curl -X POST http://control-plane:8000/register \\ -H \"Content-Type: application/json\" \\ -d '{ \"tenant\": \"team-alpha\", \"name\": \"unsanctioned-tool\", \"url\": \"https://api.example.com\", \"owner\": \"team-alpha@company.com\" }' Discover existing tools: bash curl http://control-plane:8000/register?tenant_slug=team-alpha Apply governance: Write policies for discovered tools Enforce quotas Monitor usage Business value: Eliminate shadow IT, enable proper governance. Technical Questions How fast is the kill switch? Local testing: < 1 second Production target: < 5 seconds end-to-end Breakdown: - Database update: < 100ms - State propagation: < 1s - Adapter notification: < 1s - Full system propagation: < 5s Factors affecting speed: - Database latency - Network latency to adapters - Adapter implementation quality Note: Kill switch speed depends on adapter implementation. Ensure adapters check kill-switch state frequently. Where are provenance manifests stored? Current (R&D): - Local filesystem: .data/provenance/ - Simple file-based storage Production recommendations: - Immutable storage: S3 + Glacier for long-term retention - Database: PostgreSQL JSONB column for queryable storage - Transparency log: Sigstore Rekor for public verification Why immutable storage matters: - Compliance requires non-repudiation - Can't delete or modify past manifests - Append-only ensures audit integrity Do policies support hierarchical budgets? Current: Flat quotas per tenant-tool pair Example: { \"quotas\": { \"platform-eng\": { \"openai-gpt4\": 1000 } } } Future (planned): - Hierarchical budgets (org \u2192 team \u2192 tool) - Time-based quotas (per day, per month) - Shared quotas across tools Workaround today: - Use Rego policies to implement custom logic - Track usage in external system - Pre-aggregate quotas How is authentication handled? Current: \u274c No authentication (prototype) Production requirements: - API keys for service-to-service auth - OIDC for admin console - mTLS for service mesh environments Security note: Never expose control plane without authentication in production. Can I integrate with SIEM/alerts? Yes! Multiple integration points: Structured logs: json { \"event\": \"kill_switch.disabled\", \"tenant\": \"platform-eng\", \"tool\": \"compromised-tool\", \"reason\": \"security_incident\" } Ship these to your SIEM (Splunk, Datadog, etc.) Policy logs: Query policy_logs table for policy decisions Future webhooks: Real-time notifications for kill-switch events (planned) Example integration: # Forward logs to SIEM import structlog from your_siem import forward_log logger = structlog.get_logger() logger.info(\"kill_switch.disabled\", tenant=\"platform-eng\", tool=\"compromised-tool\") # SIEM forwarder picks up structured log How do I add support for a new agent framework? Steps: Create adapter: ```python # packages/mcp_adapters/my_framework_adapter.py class MyFrameworkAdapter: async def invoke_tool(self, tool_name, params): # Check policy decision = await control_plane.check_policy(...) if not decision.allow: raise PolicyDenied(decision.reason) # Invoke tool result = await actual_tool_call(tool_name, params) # Sign provenance manifest = await control_plane.sign_provenance(...) return result ``` Integrate with framework: Hook into framework's tool invocation point Use adapter for all tool calls Test: Write unit tests Test policy enforcement Test kill-switch behavior See existing adapters for examples: - agentkit_adapter.py \u2013 OpenAI AgentKit - langgraph_middleware.py \u2013 LangGraph - skills_hook.ts \u2013 Claude Skills Deployment Questions Can I deploy this in Kubernetes? Yes! Sentinel MCP is containerized and Kubernetes-ready. Components: - Control plane: FastAPI app (Dockerfile included) - OPA: Sidecar or separate service - Database: External managed PostgreSQL - Admin console: Static site on CDN See: - apps/control-plane/Dockerfile for container build - infra/terraform/ (stub) for infrastructure as code Production considerations: - Use managed databases (RDS, Cloud SQL) - Configure secrets management (Vault, Secrets Manager) - Set up monitoring and alerting - Use service mesh for mTLS (optional) What are the resource requirements? Minimum (development): - CPU: 2 cores - Memory: 4GB - Storage: 10GB Recommended (production): - CPU: 4+ cores - Memory: 8GB+ - Storage: 100GB+ (for audit logs) Scaling: - Control plane: Horizontal scaling (stateless) - Database: Read replicas for reporting - OPA: Scales horizontally (stateless) How do I handle secrets in production? Current (R&D): - Environment variables in .env Production recommendations: - HashiCorp Vault: Inject secrets at runtime - Cloud Secrets Manager: AWS Secrets Manager, GCP Secret Manager - Kubernetes Secrets: Use with external secrets operator - Rotation: Automated rotation schedules Secrets to manage: - Database credentials - Signing keys - API keys (if using external services) - OPA bundle encryption keys Policy Questions How do I write effective policies? Start simple: default allow := false allow { input.tool in data.allowed_tools[input.tenant] } Add complexity gradually: - Quota checks - Purpose validation - Time-based rules - Context-aware decisions See: Policy Playbook for examples and best practices. Can policies be tested? Yes! Multiple approaches: OPA test files: rego test_allowed { allow with input as { \"tenant\": \"platform-eng\", \"tool\": \"allowed-tool\" } } Integration tests: python def test_policy_allows_valid_request(): response = client.post(\"/policy/check\", json={...}) assert response.json()[\"allow\"] == True Policy probes in admin console: Test policies before deployment Validate behavior How do I update policies? Development: - Edit Rego files in opa/ - Restart OPA container - Policies reload automatically Production (recommended): - GitOps workflow - Policy bundles from Git - Automated testing before deployment - Rollback capability Process: 1. Edit policies in Git 2. CI runs tests 3. Bundle created on success 4. Deployed to OPA 5. Verified in staging first Performance Questions What's the latency impact? Policy check overhead: - OPA evaluation: < 1ms typically - Database query: < 5ms typically - Total: < 10ms p95 For comparison: - Typical API call: 50-500ms - Policy check overhead: ~2-5% of total latency Optimization: - Policy decision caching (future) - Database connection pooling - OPA sidecar (reduces network latency) How many policy checks per second? Target: 1000+ policy checks/second per control plane instance Scaling: - Horizontal scaling (stateless design) - Load balancer distribution - Database connection pooling - OPA scales independently Bottlenecks: - Database write capacity (policy logs) - Network bandwidth - OPA evaluation (rarely) Troubleshooting Policy denies expected action Debugging steps: Check policy logs: sql SELECT decision, reason, created_at FROM policy_logs ORDER BY created_at DESC LIMIT 10; Test policy directly: bash opa eval \\ --data opa/data.json \\ --input input.json \\ 'data.sentinel.policy.allow' Verify input: Check tenant/tool names match Verify quotas in OPA data Check purpose values See: Runbooks for detailed troubleshooting. Kill switch not working Symptoms: Tool remains accessible after kill-switch trigger Check: 1. Is tool marked as is_active = false in database? 2. Are adapters checking kill-switch state? 3. Are adapters receiving kill notifications? 4. Is there cached state? Debug: # Check database state curl http://control-plane:8000/register?tenant_slug=platform-eng # Check adapter logs # Look for kill-switch signals # Verify policy checks # Should deny when is_active = false See: Runbooks for detailed procedures. Still Have Questions? \ud83d\udcd6 Check the full documentation \ud83d\udc1b Open an issue on GitHub \ud83d\udcac Review Runbooks for operational questions","title":"FAQ"},{"location":"appendix/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"appendix/faq/#project-status","text":"","title":"Project Status"},{"location":"appendix/faq/#is-this-a-commercial-product","text":"No. This is a personal R&D exploration project , not a commercial product. I am not seeking to develop this into a product or commercialize it. This project represents my passion for AI governance and continuous exploration of how to make autonomous systems safer and more controllable. It's shared openly for learning, research, and community discussion.","title":"Is this a commercial product?"},{"location":"appendix/faq/#whats-the-purpose-of-this-project","text":"This project is an exploration of governance patterns for AI agents\u2014born from curiosity, passion, and continuous learning. The goal is to advance understanding of how to govern autonomous systems, share ideas with the community, and contribute to the broader conversation about AI agent safety and controllability.","title":"What's the purpose of this project?"},{"location":"appendix/faq/#general-questions","text":"","title":"General Questions"},{"location":"appendix/faq/#what-is-sentinel-mcp","text":"Sentinel MCP is a control plane for AI agents that provides governance, security, and compliance for autonomous systems. It sits between AI agents and the tools they want to use, enforcing policies, tracking provenance, and enabling instant control through kill switches. Think of it as: A security guard, budget manager, and compliance auditor all rolled into one system, specifically designed for AI agents.","title":"What is Sentinel MCP?"},{"location":"appendix/faq/#is-sentinel-mcp-production-ready","text":"Status: \ud83e\uddea R&D Prototype \u2013 Active development What's working: - \u2705 Core control plane functionality - \u2705 Policy engine integration - \u2705 Kill switch capability - \u2705 Provenance signing - \u2705 Multi-framework adapters - \u2705 Admin console What needs work for production: - \ud83d\udd04 Authentication/authorization (currently open) - \ud83d\udd04 Production-grade secrets management - \ud83d\udd04 Sigstore integration for provenance - \ud83d\udd04 Enhanced observability - \ud83d\udd04 Performance optimization Recommendation: Use for R&D, pilot projects, and learning. For production deployments, plan for additional hardening (see Security Guide ).","title":"Is Sentinel MCP production-ready?"},{"location":"appendix/faq/#how-does-sentinel-mcp-differ-from-api-gateways","text":"API gateways are designed for human users and traditional applications. Sentinel MCP is designed specifically for AI agents with unique challenges: Feature API Gateway Sentinel MCP Designed for Human users, traditional apps AI agents Policy evaluation Basic auth/rate limiting Rich context-aware policies Provenance Logs only Cryptographic signatures Kill switch Manual or complex Instant, system-wide Agent awareness No Yes (framework adapters) Key difference: Sentinel MCP understands that agents are autonomous, unpredictable, and need runtime governance.","title":"How does Sentinel MCP differ from API gateways?"},{"location":"appendix/faq/#can-i-use-sqlite-instead-of-postgresql","text":"Not currently. The schema relies on PostgreSQL-specific features: - JSONB for flexible metadata storage - Advanced indexing for performance - ACID compliance for audit logs For testing: Consider using PostgreSQL in Docker for local development. Future: Could add SQLite support for testing, but PostgreSQL is recommended for any real usage.","title":"Can I use SQLite instead of PostgreSQL?"},{"location":"appendix/faq/#real-world-scenarios","text":"","title":"Real-World Scenarios"},{"location":"appendix/faq/#scenario-an-agent-is-making-too-many-api-calls-and-exceeding-our-budget","text":"Problem: Your AI agent is calling an expensive API repeatedly, running up costs. Solution: 1. Define a quota policy: rego quota := data.quotas[input.tenant][input.tool] input.usage < quota Set quotas in OPA data: json { \"quotas\": { \"platform-eng\": { \"openai-gpt4\": 1000 } } } Result: When quota is exceeded, requests are denied with clear messaging. Business value: Prevents budget overruns automatically, no manual intervention needed.","title":"Scenario: \"An agent is making too many API calls and exceeding our budget\""},{"location":"appendix/faq/#scenario-we-need-to-prove-compliance-during-an-audit","text":"Problem: Auditor asks: \"Can you prove which actions were authorized?\" Solution: 1. Every action generates a provenance manifest: json { \"id\": \"manifest-123\", \"tenant\": \"platform-eng\", \"tool\": \"customer-api\", \"action\": \"invoke\", \"authorized\": true, \"signature\": \"...\", \"timestamp\": \"2024-01-15T10:30:00Z\" } Manifests are cryptographically signed (non-repudiation) Export manifests for audit window: bash # Query database for manifests in date range SELECT * FROM provenance_manifests WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31' Business value: Pass compliance audits with cryptographic proof, not just logs.","title":"Scenario: \"We need to prove compliance during an audit\""},{"location":"appendix/faq/#scenario-a-security-incident-requires-immediately-disabling-a-tool","text":"Problem: Security team detects suspicious activity. Need to block tool access NOW. Solution: 1. Trigger kill switch: bash curl -X POST http://control-plane:8000/kill \\ -H \"Content-Type: application/json\" \\ -d '{\"tenant\": \"platform-eng\", \"tool\": \"compromised-tool\"}' What happens: Tool marked as is_active = false in database (< 100ms) Adapters notified via hooks (< 1s) All future policy checks deny immediately Audit log entry created Target MTTR: < 5 seconds from incident to tool disablement Business value: Respond to incidents instantly, reducing breach impact.","title":"Scenario: \"A security incident requires immediately disabling a tool\""},{"location":"appendix/faq/#scenario-teams-are-deploying-agents-without-coordination","text":"Problem: Shadow IT\u2014teams deploying agents and tools without central oversight. Solution: 1. Register all tools: bash curl -X POST http://control-plane:8000/register \\ -H \"Content-Type: application/json\" \\ -d '{ \"tenant\": \"team-alpha\", \"name\": \"unsanctioned-tool\", \"url\": \"https://api.example.com\", \"owner\": \"team-alpha@company.com\" }' Discover existing tools: bash curl http://control-plane:8000/register?tenant_slug=team-alpha Apply governance: Write policies for discovered tools Enforce quotas Monitor usage Business value: Eliminate shadow IT, enable proper governance.","title":"Scenario: \"Teams are deploying agents without coordination\""},{"location":"appendix/faq/#technical-questions","text":"","title":"Technical Questions"},{"location":"appendix/faq/#how-fast-is-the-kill-switch","text":"Local testing: < 1 second Production target: < 5 seconds end-to-end Breakdown: - Database update: < 100ms - State propagation: < 1s - Adapter notification: < 1s - Full system propagation: < 5s Factors affecting speed: - Database latency - Network latency to adapters - Adapter implementation quality Note: Kill switch speed depends on adapter implementation. Ensure adapters check kill-switch state frequently.","title":"How fast is the kill switch?"},{"location":"appendix/faq/#where-are-provenance-manifests-stored","text":"Current (R&D): - Local filesystem: .data/provenance/ - Simple file-based storage Production recommendations: - Immutable storage: S3 + Glacier for long-term retention - Database: PostgreSQL JSONB column for queryable storage - Transparency log: Sigstore Rekor for public verification Why immutable storage matters: - Compliance requires non-repudiation - Can't delete or modify past manifests - Append-only ensures audit integrity","title":"Where are provenance manifests stored?"},{"location":"appendix/faq/#do-policies-support-hierarchical-budgets","text":"Current: Flat quotas per tenant-tool pair Example: { \"quotas\": { \"platform-eng\": { \"openai-gpt4\": 1000 } } } Future (planned): - Hierarchical budgets (org \u2192 team \u2192 tool) - Time-based quotas (per day, per month) - Shared quotas across tools Workaround today: - Use Rego policies to implement custom logic - Track usage in external system - Pre-aggregate quotas","title":"Do policies support hierarchical budgets?"},{"location":"appendix/faq/#how-is-authentication-handled","text":"Current: \u274c No authentication (prototype) Production requirements: - API keys for service-to-service auth - OIDC for admin console - mTLS for service mesh environments Security note: Never expose control plane without authentication in production.","title":"How is authentication handled?"},{"location":"appendix/faq/#can-i-integrate-with-siemalerts","text":"Yes! Multiple integration points: Structured logs: json { \"event\": \"kill_switch.disabled\", \"tenant\": \"platform-eng\", \"tool\": \"compromised-tool\", \"reason\": \"security_incident\" } Ship these to your SIEM (Splunk, Datadog, etc.) Policy logs: Query policy_logs table for policy decisions Future webhooks: Real-time notifications for kill-switch events (planned) Example integration: # Forward logs to SIEM import structlog from your_siem import forward_log logger = structlog.get_logger() logger.info(\"kill_switch.disabled\", tenant=\"platform-eng\", tool=\"compromised-tool\") # SIEM forwarder picks up structured log","title":"Can I integrate with SIEM/alerts?"},{"location":"appendix/faq/#how-do-i-add-support-for-a-new-agent-framework","text":"Steps: Create adapter: ```python # packages/mcp_adapters/my_framework_adapter.py class MyFrameworkAdapter: async def invoke_tool(self, tool_name, params): # Check policy decision = await control_plane.check_policy(...) if not decision.allow: raise PolicyDenied(decision.reason) # Invoke tool result = await actual_tool_call(tool_name, params) # Sign provenance manifest = await control_plane.sign_provenance(...) return result ``` Integrate with framework: Hook into framework's tool invocation point Use adapter for all tool calls Test: Write unit tests Test policy enforcement Test kill-switch behavior See existing adapters for examples: - agentkit_adapter.py \u2013 OpenAI AgentKit - langgraph_middleware.py \u2013 LangGraph - skills_hook.ts \u2013 Claude Skills","title":"How do I add support for a new agent framework?"},{"location":"appendix/faq/#deployment-questions","text":"","title":"Deployment Questions"},{"location":"appendix/faq/#can-i-deploy-this-in-kubernetes","text":"Yes! Sentinel MCP is containerized and Kubernetes-ready. Components: - Control plane: FastAPI app (Dockerfile included) - OPA: Sidecar or separate service - Database: External managed PostgreSQL - Admin console: Static site on CDN See: - apps/control-plane/Dockerfile for container build - infra/terraform/ (stub) for infrastructure as code Production considerations: - Use managed databases (RDS, Cloud SQL) - Configure secrets management (Vault, Secrets Manager) - Set up monitoring and alerting - Use service mesh for mTLS (optional)","title":"Can I deploy this in Kubernetes?"},{"location":"appendix/faq/#what-are-the-resource-requirements","text":"Minimum (development): - CPU: 2 cores - Memory: 4GB - Storage: 10GB Recommended (production): - CPU: 4+ cores - Memory: 8GB+ - Storage: 100GB+ (for audit logs) Scaling: - Control plane: Horizontal scaling (stateless) - Database: Read replicas for reporting - OPA: Scales horizontally (stateless)","title":"What are the resource requirements?"},{"location":"appendix/faq/#how-do-i-handle-secrets-in-production","text":"Current (R&D): - Environment variables in .env Production recommendations: - HashiCorp Vault: Inject secrets at runtime - Cloud Secrets Manager: AWS Secrets Manager, GCP Secret Manager - Kubernetes Secrets: Use with external secrets operator - Rotation: Automated rotation schedules Secrets to manage: - Database credentials - Signing keys - API keys (if using external services) - OPA bundle encryption keys","title":"How do I handle secrets in production?"},{"location":"appendix/faq/#policy-questions","text":"","title":"Policy Questions"},{"location":"appendix/faq/#how-do-i-write-effective-policies","text":"Start simple: default allow := false allow { input.tool in data.allowed_tools[input.tenant] } Add complexity gradually: - Quota checks - Purpose validation - Time-based rules - Context-aware decisions See: Policy Playbook for examples and best practices.","title":"How do I write effective policies?"},{"location":"appendix/faq/#can-policies-be-tested","text":"Yes! Multiple approaches: OPA test files: rego test_allowed { allow with input as { \"tenant\": \"platform-eng\", \"tool\": \"allowed-tool\" } } Integration tests: python def test_policy_allows_valid_request(): response = client.post(\"/policy/check\", json={...}) assert response.json()[\"allow\"] == True Policy probes in admin console: Test policies before deployment Validate behavior","title":"Can policies be tested?"},{"location":"appendix/faq/#how-do-i-update-policies","text":"Development: - Edit Rego files in opa/ - Restart OPA container - Policies reload automatically Production (recommended): - GitOps workflow - Policy bundles from Git - Automated testing before deployment - Rollback capability Process: 1. Edit policies in Git 2. CI runs tests 3. Bundle created on success 4. Deployed to OPA 5. Verified in staging first","title":"How do I update policies?"},{"location":"appendix/faq/#performance-questions","text":"","title":"Performance Questions"},{"location":"appendix/faq/#whats-the-latency-impact","text":"Policy check overhead: - OPA evaluation: < 1ms typically - Database query: < 5ms typically - Total: < 10ms p95 For comparison: - Typical API call: 50-500ms - Policy check overhead: ~2-5% of total latency Optimization: - Policy decision caching (future) - Database connection pooling - OPA sidecar (reduces network latency)","title":"What's the latency impact?"},{"location":"appendix/faq/#how-many-policy-checks-per-second","text":"Target: 1000+ policy checks/second per control plane instance Scaling: - Horizontal scaling (stateless design) - Load balancer distribution - Database connection pooling - OPA scales independently Bottlenecks: - Database write capacity (policy logs) - Network bandwidth - OPA evaluation (rarely)","title":"How many policy checks per second?"},{"location":"appendix/faq/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"appendix/faq/#policy-denies-expected-action","text":"Debugging steps: Check policy logs: sql SELECT decision, reason, created_at FROM policy_logs ORDER BY created_at DESC LIMIT 10; Test policy directly: bash opa eval \\ --data opa/data.json \\ --input input.json \\ 'data.sentinel.policy.allow' Verify input: Check tenant/tool names match Verify quotas in OPA data Check purpose values See: Runbooks for detailed troubleshooting.","title":"Policy denies expected action"},{"location":"appendix/faq/#kill-switch-not-working","text":"Symptoms: Tool remains accessible after kill-switch trigger Check: 1. Is tool marked as is_active = false in database? 2. Are adapters checking kill-switch state? 3. Are adapters receiving kill notifications? 4. Is there cached state? Debug: # Check database state curl http://control-plane:8000/register?tenant_slug=platform-eng # Check adapter logs # Look for kill-switch signals # Verify policy checks # Should deny when is_active = false See: Runbooks for detailed procedures.","title":"Kill switch not working"},{"location":"appendix/faq/#still-have-questions","text":"\ud83d\udcd6 Check the full documentation \ud83d\udc1b Open an issue on GitHub \ud83d\udcac Review Runbooks for operational questions","title":"Still Have Questions?"},{"location":"appendix/glossary/","text":"Glossary Core Concepts Sentinel MCP Control plane for AI agents that provides governance, security, and compliance. Sits between AI agents and tools, enforcing policies, tracking provenance, and enabling instant control through kill switches. Think of it as: Air traffic control for your AI tool ecosystem. Control Plane A centralized system that manages policy enforcement, tool inventory, and audit logging. All agent-to-tool interactions flow through the control plane, ensuring consistent governance. Why it matters: Enables runtime governance for autonomous systems where traditional security models don't work. AI Agent An autonomous software system that can make decisions, use tools, and take actions without human intervention for each step. Examples include ChatGPT Actions, Claude Tools, and LangGraph workflows. Key characteristics: - Autonomous decision-making - Tool usage capabilities - Unpredictable behavior - Infinitely scalable Model-Context Protocol (MCP) A protocol for agent tools/skills to register capabilities and exchange structured context. Enables dynamic tool discovery and integration. Relevance: Sentinal MCP governs MCP servers and skills, ensuring they're used safely and compliantly. Policy & Governance Policy Engine The component that evaluates authorization requests against policies. Sentinel MCP uses Open Policy Agent (OPA) as its policy engine. How it works: 1. Receives authorization request with context 2. Evaluates policies written in Rego 3. Returns allow/deny decision with reasoning Rego The policy language used by Open Policy Agent. Declarative language for expressing authorization policies. Example: allow { input.tool in data.allowed_tools[input.tenant] input.usage < data.quotas[input.tenant][input.tool] } Why Rego: - Policy-as-code (version control, testing) - Declarative (describe \"what\" not \"how\") - Fast evaluation (microseconds) Policy-as-Code Storing policies as code files (e.g., Rego files) rather than configuration UIs or databases. Benefits: - Version control (Git) - Automated testing - GitOps deployment - Consistency across environments RBAC (Role-Based Access Control) Access control based on roles assigned to users/agents. Example: \"Only agents with 'admin' role can use 'delete-user' tool.\" In Sentinel MCP: Policies can check roles as part of authorization decisions. ABAC (Attribute-Based Access Control) Access control based on attributes (properties) of the request, user, resource, or environment. Example: \"Agents can only use 'customer-api' during business hours.\" In Sentinel MCP: Policies can check any attribute (tenant, tool, purpose, time, context). Quota A limit on resource usage, typically enforced per tenant, tool, and time period. Example: \"Maximum 1,000 API calls per day per team.\" Purpose: Prevent budget overruns and resource exhaustion. In Sentinel MCP: Quotas are enforced through policy evaluation. Security & Compliance Kill Switch An emergency mechanism to instantly disable a tool system-wide. When triggered, the tool is marked inactive, credentials are revoked, and all future requests are denied. Target MTTR: < 5 seconds from trigger to system-wide disablement. Use cases: - Security incidents - Budget emergencies - Compliance violations - Testing and drills Provenance A cryptographically signed record proving that an action occurred, who performed it, when it happened, and whether it was authorized. Components: - Action metadata (what, who, when) - Cryptographic signature (non-repudiation) - Authorization proof (policy decision) Use cases: - Compliance audits - Forensic investigations - Accountability - Trust verification Provenance Manifest A structured document containing provenance information for a specific action. Cryptographically signed to ensure integrity. Structure: { \"id\": \"manifest-uuid\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"tenant\": \"platform-eng\", \"tool\": \"customer-api\", \"action\": \"invoke\", \"authorized\": true, \"signature\": \"...\" } C2PA (Coalition for Content Provenance and Authenticity) A standard for content provenance, specifying how to create and verify provenance manifests. Sentinel MCP uses C2PA-style manifests. Why it matters: Industry-standard format ensures interoperability and compliance. Non-Repudiation A cryptographic property ensuring that an action cannot be denied. Cryptographic signatures provide non-repudiation\u2014you can prove who signed what. In Sentinel MCP: Provenance manifests are cryptographically signed, providing non-repudiation. Audit Trail A chronological record of all actions and decisions, stored for compliance and investigation purposes. In Sentinel MCP: - Policy decisions logged - Kill-switch events logged - Provenance manifests stored - Structured logs for querying Technology Stack Open Policy Agent (OPA) Open-source policy engine used by Sentinel MCP. Evaluates policies written in Rego and returns authorization decisions. Key features: - Fast evaluation (microseconds) - Language-agnostic (REST API) - Policy-as-code support - Proven at scale FastAPI Modern Python web framework used for the Sentinel MCP control plane API. Why FastAPI: - Async/await support - Automatic OpenAPI documentation - Type hints and validation - High performance SQLAlchemy Python SQL toolkit and ORM used for database operations in Sentinel MCP. Why SQLAlchemy: - Database abstraction - Migration support (Alembic) - Type safety - Mature ecosystem PostgreSQL Relational database used by Sentinel MCP for storing tenants, tools, policy logs, and audit data. Why PostgreSQL: - JSONB support (flexible metadata) - ACID compliance (critical for audit logs) - Mature ecosystem - Production-ready Redis In-memory data store used for caching and future rate limiting in Sentinel MCP. Planned uses: - Rate limit counters - Kill-switch broadcast cache - Policy decision cache Structlog Python structured logging library used by Sentinel MCP for queryable, JSON-formatted logs. Benefits: - Structured output (JSON) - Context preservation - Queryable logs - SIEM integration OpenTelemetry (OTel) Observability framework for generating traces, metrics, and logs. Sentinel MCP uses OTel for distributed tracing. Benefits: - Standardized observability - Vendor-agnostic - Rich context propagation Sigstore Open-source signing infrastructure providing public-key infrastructure for software signing. Future target for Sentinel MCP provenance. Components: - Cosign (signing tool) - Rekor (transparency log) - Fulcio (certificate authority) Why Sigstore: - Public-key infrastructure - Transparency logs - Industry standard Agent Frameworks AgentKit (OpenAI) OpenAI's framework for building AI agents with tool usage capabilities. In Sentinel MCP: agentkit_adapter.py integrates AgentKit agents with Sentinel MCP governance. LangGraph A framework for building stateful, multi-actor applications with LLMs. In Sentinel MCP: langgraph_middleware.py provides middleware for LangGraph applications. Claude Skills Anthropic's framework for extending Claude with custom capabilities. In Sentinel MCP: skills_hook.ts provides a TypeScript hook for Claude Skills integration. MCP Server A server implementing the Model-Context Protocol, exposing tools and capabilities to agents. In Sentinel MCP: MCP servers are registered and governed through the control plane. Operations MTTR (Mean Time To Recovery) The average time to recover from an incident. For kill switches, Sentinel MCP targets < 5 seconds MTTR. Components: - Detection time - Response time - Recovery time Chaos Engineering The practice of intentionally introducing failures to test system resilience. In Sentinel MCP: chaos_kill.sh performs kill-switch drills to verify system behavior. Shadow IT Technology solutions deployed by teams without central IT approval or oversight. Problem: Creates security blind spots and compliance gaps. Solution: Sentinel MCP's registry discovers and governs all tools, eliminating shadow IT. GitOps A methodology for managing infrastructure and applications using Git as the source of truth. In Sentinel MCP: Policies can be managed via GitOps workflows, with automated testing and deployment. Compliance & Governance SOC 2 A compliance framework for security, availability, processing integrity, confidentiality, and privacy. Relevance: Sentinel MCP's audit trails and provenance support SOC 2 compliance. HIPAA Health Insurance Portability and Accountability Act, governing healthcare data protection. Relevance: Sentinel MCP can enforce policies preventing unauthorized access to patient data. Compliance Audit A review process to verify adherence to regulations and standards. How Sentinel MCP helps: - Complete audit trails - Cryptographic proof of actions - Policy enforcement evidence - Usage tracking and reporting RBAC vs ABAC RBAC: Role-based (simpler, less flexible) ABAC: Attribute-based (more flexible, more complex) In Sentinel MCP: Policies can implement both RBAC and ABAC patterns, or combine them. AI/ML Terms LLM (Large Language Model) A type of AI model trained on vast amounts of text data. Examples: GPT-4, Claude, Llama. Relevance: LLMs power AI agents, which Sentinel MCP governs. Multi-Agent System A system where multiple AI agents collaborate to accomplish tasks. Challenge: Requires coordination and governance. Solution: Sentinel MCP provides centralized governance for multi-agent systems. Tool Calling The capability of AI agents to invoke external tools (APIs, functions, scripts) to extend their capabilities. In Sentinel MCP: All tool calls are governed through policy enforcement. Prompt Injection A security vulnerability where malicious input tricks an AI system into unintended behavior. Mitigation: Sentinel MCP's policy enforcement sits between agents and tools, preventing unauthorized actions regardless of prompt content. Hallucination When an AI model generates incorrect or fabricated information. Relevance: While Sentinel MCP doesn't prevent hallucinations, it ensures that even hallucinated tool calls are properly governed. Fine-Tuning The process of training an AI model on additional data to improve performance on specific tasks. Note: Sentinel MCP operates at the runtime governance layer, independent of model training. Architecture Terms Sidecar Pattern A deployment pattern where a helper container runs alongside the main application container. In Sentinel MCP: OPA can run as a sidecar alongside the control plane for reduced latency. Microservices An architectural approach where applications are built as small, independent services. In Sentinel MCP: Control plane is designed as a microservice, enabling horizontal scaling. Service Mesh A dedicated infrastructure layer for managing service-to-service communication. Future: Sentinel MCP could integrate with service meshes for mTLS and advanced routing. API Gateway A service that sits between clients and backend services, providing routing, authentication, rate limiting, etc. Difference: Sentinel MCP is agent-aware and policy-driven, whereas traditional API gateways are user-focused. Metrics & Observability P50, P95, P99 Percentiles indicating latency distribution: - P50: Median latency (50% of requests) - P95: 95th percentile (95% of requests faster) - P99: 99th percentile (99% of requests faster) In Sentinel MCP: Policy check latency targets < 10ms p95. Throughput The number of requests processed per second. In Sentinel MCP: Target: 1000+ policy checks/second per instance. Latency The time taken to process a request. In Sentinel MCP: Policy check adds < 10ms typically. Need more terms? Check the full documentation or open an issue on GitHub.","title":"Glossary"},{"location":"appendix/glossary/#glossary","text":"","title":"Glossary"},{"location":"appendix/glossary/#core-concepts","text":"","title":"Core Concepts"},{"location":"appendix/glossary/#sentinel-mcp","text":"Control plane for AI agents that provides governance, security, and compliance. Sits between AI agents and tools, enforcing policies, tracking provenance, and enabling instant control through kill switches. Think of it as: Air traffic control for your AI tool ecosystem.","title":"Sentinel MCP"},{"location":"appendix/glossary/#control-plane","text":"A centralized system that manages policy enforcement, tool inventory, and audit logging. All agent-to-tool interactions flow through the control plane, ensuring consistent governance. Why it matters: Enables runtime governance for autonomous systems where traditional security models don't work.","title":"Control Plane"},{"location":"appendix/glossary/#ai-agent","text":"An autonomous software system that can make decisions, use tools, and take actions without human intervention for each step. Examples include ChatGPT Actions, Claude Tools, and LangGraph workflows. Key characteristics: - Autonomous decision-making - Tool usage capabilities - Unpredictable behavior - Infinitely scalable","title":"AI Agent"},{"location":"appendix/glossary/#model-context-protocol-mcp","text":"A protocol for agent tools/skills to register capabilities and exchange structured context. Enables dynamic tool discovery and integration. Relevance: Sentinal MCP governs MCP servers and skills, ensuring they're used safely and compliantly.","title":"Model-Context Protocol (MCP)"},{"location":"appendix/glossary/#policy-governance","text":"","title":"Policy &amp; Governance"},{"location":"appendix/glossary/#policy-engine","text":"The component that evaluates authorization requests against policies. Sentinel MCP uses Open Policy Agent (OPA) as its policy engine. How it works: 1. Receives authorization request with context 2. Evaluates policies written in Rego 3. Returns allow/deny decision with reasoning","title":"Policy Engine"},{"location":"appendix/glossary/#rego","text":"The policy language used by Open Policy Agent. Declarative language for expressing authorization policies. Example: allow { input.tool in data.allowed_tools[input.tenant] input.usage < data.quotas[input.tenant][input.tool] } Why Rego: - Policy-as-code (version control, testing) - Declarative (describe \"what\" not \"how\") - Fast evaluation (microseconds)","title":"Rego"},{"location":"appendix/glossary/#policy-as-code","text":"Storing policies as code files (e.g., Rego files) rather than configuration UIs or databases. Benefits: - Version control (Git) - Automated testing - GitOps deployment - Consistency across environments","title":"Policy-as-Code"},{"location":"appendix/glossary/#rbac-role-based-access-control","text":"Access control based on roles assigned to users/agents. Example: \"Only agents with 'admin' role can use 'delete-user' tool.\" In Sentinel MCP: Policies can check roles as part of authorization decisions.","title":"RBAC (Role-Based Access Control)"},{"location":"appendix/glossary/#abac-attribute-based-access-control","text":"Access control based on attributes (properties) of the request, user, resource, or environment. Example: \"Agents can only use 'customer-api' during business hours.\" In Sentinel MCP: Policies can check any attribute (tenant, tool, purpose, time, context).","title":"ABAC (Attribute-Based Access Control)"},{"location":"appendix/glossary/#quota","text":"A limit on resource usage, typically enforced per tenant, tool, and time period. Example: \"Maximum 1,000 API calls per day per team.\" Purpose: Prevent budget overruns and resource exhaustion. In Sentinel MCP: Quotas are enforced through policy evaluation.","title":"Quota"},{"location":"appendix/glossary/#security-compliance","text":"","title":"Security &amp; Compliance"},{"location":"appendix/glossary/#kill-switch","text":"An emergency mechanism to instantly disable a tool system-wide. When triggered, the tool is marked inactive, credentials are revoked, and all future requests are denied. Target MTTR: < 5 seconds from trigger to system-wide disablement. Use cases: - Security incidents - Budget emergencies - Compliance violations - Testing and drills","title":"Kill Switch"},{"location":"appendix/glossary/#provenance","text":"A cryptographically signed record proving that an action occurred, who performed it, when it happened, and whether it was authorized. Components: - Action metadata (what, who, when) - Cryptographic signature (non-repudiation) - Authorization proof (policy decision) Use cases: - Compliance audits - Forensic investigations - Accountability - Trust verification","title":"Provenance"},{"location":"appendix/glossary/#provenance-manifest","text":"A structured document containing provenance information for a specific action. Cryptographically signed to ensure integrity. Structure: { \"id\": \"manifest-uuid\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"tenant\": \"platform-eng\", \"tool\": \"customer-api\", \"action\": \"invoke\", \"authorized\": true, \"signature\": \"...\" }","title":"Provenance Manifest"},{"location":"appendix/glossary/#c2pa-coalition-for-content-provenance-and-authenticity","text":"A standard for content provenance, specifying how to create and verify provenance manifests. Sentinel MCP uses C2PA-style manifests. Why it matters: Industry-standard format ensures interoperability and compliance.","title":"C2PA (Coalition for Content Provenance and Authenticity)"},{"location":"appendix/glossary/#non-repudiation","text":"A cryptographic property ensuring that an action cannot be denied. Cryptographic signatures provide non-repudiation\u2014you can prove who signed what. In Sentinel MCP: Provenance manifests are cryptographically signed, providing non-repudiation.","title":"Non-Repudiation"},{"location":"appendix/glossary/#audit-trail","text":"A chronological record of all actions and decisions, stored for compliance and investigation purposes. In Sentinel MCP: - Policy decisions logged - Kill-switch events logged - Provenance manifests stored - Structured logs for querying","title":"Audit Trail"},{"location":"appendix/glossary/#technology-stack","text":"","title":"Technology Stack"},{"location":"appendix/glossary/#open-policy-agent-opa","text":"Open-source policy engine used by Sentinel MCP. Evaluates policies written in Rego and returns authorization decisions. Key features: - Fast evaluation (microseconds) - Language-agnostic (REST API) - Policy-as-code support - Proven at scale","title":"Open Policy Agent (OPA)"},{"location":"appendix/glossary/#fastapi","text":"Modern Python web framework used for the Sentinel MCP control plane API. Why FastAPI: - Async/await support - Automatic OpenAPI documentation - Type hints and validation - High performance","title":"FastAPI"},{"location":"appendix/glossary/#sqlalchemy","text":"Python SQL toolkit and ORM used for database operations in Sentinel MCP. Why SQLAlchemy: - Database abstraction - Migration support (Alembic) - Type safety - Mature ecosystem","title":"SQLAlchemy"},{"location":"appendix/glossary/#postgresql","text":"Relational database used by Sentinel MCP for storing tenants, tools, policy logs, and audit data. Why PostgreSQL: - JSONB support (flexible metadata) - ACID compliance (critical for audit logs) - Mature ecosystem - Production-ready","title":"PostgreSQL"},{"location":"appendix/glossary/#redis","text":"In-memory data store used for caching and future rate limiting in Sentinel MCP. Planned uses: - Rate limit counters - Kill-switch broadcast cache - Policy decision cache","title":"Redis"},{"location":"appendix/glossary/#structlog","text":"Python structured logging library used by Sentinel MCP for queryable, JSON-formatted logs. Benefits: - Structured output (JSON) - Context preservation - Queryable logs - SIEM integration","title":"Structlog"},{"location":"appendix/glossary/#opentelemetry-otel","text":"Observability framework for generating traces, metrics, and logs. Sentinel MCP uses OTel for distributed tracing. Benefits: - Standardized observability - Vendor-agnostic - Rich context propagation","title":"OpenTelemetry (OTel)"},{"location":"appendix/glossary/#sigstore","text":"Open-source signing infrastructure providing public-key infrastructure for software signing. Future target for Sentinel MCP provenance. Components: - Cosign (signing tool) - Rekor (transparency log) - Fulcio (certificate authority) Why Sigstore: - Public-key infrastructure - Transparency logs - Industry standard","title":"Sigstore"},{"location":"appendix/glossary/#agent-frameworks","text":"","title":"Agent Frameworks"},{"location":"appendix/glossary/#agentkit-openai","text":"OpenAI's framework for building AI agents with tool usage capabilities. In Sentinel MCP: agentkit_adapter.py integrates AgentKit agents with Sentinel MCP governance.","title":"AgentKit (OpenAI)"},{"location":"appendix/glossary/#langgraph","text":"A framework for building stateful, multi-actor applications with LLMs. In Sentinel MCP: langgraph_middleware.py provides middleware for LangGraph applications.","title":"LangGraph"},{"location":"appendix/glossary/#claude-skills","text":"Anthropic's framework for extending Claude with custom capabilities. In Sentinel MCP: skills_hook.ts provides a TypeScript hook for Claude Skills integration.","title":"Claude Skills"},{"location":"appendix/glossary/#mcp-server","text":"A server implementing the Model-Context Protocol, exposing tools and capabilities to agents. In Sentinel MCP: MCP servers are registered and governed through the control plane.","title":"MCP Server"},{"location":"appendix/glossary/#operations","text":"","title":"Operations"},{"location":"appendix/glossary/#mttr-mean-time-to-recovery","text":"The average time to recover from an incident. For kill switches, Sentinel MCP targets < 5 seconds MTTR. Components: - Detection time - Response time - Recovery time","title":"MTTR (Mean Time To Recovery)"},{"location":"appendix/glossary/#chaos-engineering","text":"The practice of intentionally introducing failures to test system resilience. In Sentinel MCP: chaos_kill.sh performs kill-switch drills to verify system behavior.","title":"Chaos Engineering"},{"location":"appendix/glossary/#shadow-it","text":"Technology solutions deployed by teams without central IT approval or oversight. Problem: Creates security blind spots and compliance gaps. Solution: Sentinel MCP's registry discovers and governs all tools, eliminating shadow IT.","title":"Shadow IT"},{"location":"appendix/glossary/#gitops","text":"A methodology for managing infrastructure and applications using Git as the source of truth. In Sentinel MCP: Policies can be managed via GitOps workflows, with automated testing and deployment.","title":"GitOps"},{"location":"appendix/glossary/#compliance-governance","text":"","title":"Compliance &amp; Governance"},{"location":"appendix/glossary/#soc-2","text":"A compliance framework for security, availability, processing integrity, confidentiality, and privacy. Relevance: Sentinel MCP's audit trails and provenance support SOC 2 compliance.","title":"SOC 2"},{"location":"appendix/glossary/#hipaa","text":"Health Insurance Portability and Accountability Act, governing healthcare data protection. Relevance: Sentinel MCP can enforce policies preventing unauthorized access to patient data.","title":"HIPAA"},{"location":"appendix/glossary/#compliance-audit","text":"A review process to verify adherence to regulations and standards. How Sentinel MCP helps: - Complete audit trails - Cryptographic proof of actions - Policy enforcement evidence - Usage tracking and reporting","title":"Compliance Audit"},{"location":"appendix/glossary/#rbac-vs-abac","text":"RBAC: Role-based (simpler, less flexible) ABAC: Attribute-based (more flexible, more complex) In Sentinel MCP: Policies can implement both RBAC and ABAC patterns, or combine them.","title":"RBAC vs ABAC"},{"location":"appendix/glossary/#aiml-terms","text":"","title":"AI/ML Terms"},{"location":"appendix/glossary/#llm-large-language-model","text":"A type of AI model trained on vast amounts of text data. Examples: GPT-4, Claude, Llama. Relevance: LLMs power AI agents, which Sentinel MCP governs.","title":"LLM (Large Language Model)"},{"location":"appendix/glossary/#multi-agent-system","text":"A system where multiple AI agents collaborate to accomplish tasks. Challenge: Requires coordination and governance. Solution: Sentinel MCP provides centralized governance for multi-agent systems.","title":"Multi-Agent System"},{"location":"appendix/glossary/#tool-calling","text":"The capability of AI agents to invoke external tools (APIs, functions, scripts) to extend their capabilities. In Sentinel MCP: All tool calls are governed through policy enforcement.","title":"Tool Calling"},{"location":"appendix/glossary/#prompt-injection","text":"A security vulnerability where malicious input tricks an AI system into unintended behavior. Mitigation: Sentinel MCP's policy enforcement sits between agents and tools, preventing unauthorized actions regardless of prompt content.","title":"Prompt Injection"},{"location":"appendix/glossary/#hallucination","text":"When an AI model generates incorrect or fabricated information. Relevance: While Sentinel MCP doesn't prevent hallucinations, it ensures that even hallucinated tool calls are properly governed.","title":"Hallucination"},{"location":"appendix/glossary/#fine-tuning","text":"The process of training an AI model on additional data to improve performance on specific tasks. Note: Sentinel MCP operates at the runtime governance layer, independent of model training.","title":"Fine-Tuning"},{"location":"appendix/glossary/#architecture-terms","text":"","title":"Architecture Terms"},{"location":"appendix/glossary/#sidecar-pattern","text":"A deployment pattern where a helper container runs alongside the main application container. In Sentinel MCP: OPA can run as a sidecar alongside the control plane for reduced latency.","title":"Sidecar Pattern"},{"location":"appendix/glossary/#microservices","text":"An architectural approach where applications are built as small, independent services. In Sentinel MCP: Control plane is designed as a microservice, enabling horizontal scaling.","title":"Microservices"},{"location":"appendix/glossary/#service-mesh","text":"A dedicated infrastructure layer for managing service-to-service communication. Future: Sentinel MCP could integrate with service meshes for mTLS and advanced routing.","title":"Service Mesh"},{"location":"appendix/glossary/#api-gateway","text":"A service that sits between clients and backend services, providing routing, authentication, rate limiting, etc. Difference: Sentinel MCP is agent-aware and policy-driven, whereas traditional API gateways are user-focused.","title":"API Gateway"},{"location":"appendix/glossary/#metrics-observability","text":"","title":"Metrics &amp; Observability"},{"location":"appendix/glossary/#p50-p95-p99","text":"Percentiles indicating latency distribution: - P50: Median latency (50% of requests) - P95: 95th percentile (95% of requests faster) - P99: 99th percentile (99% of requests faster) In Sentinel MCP: Policy check latency targets < 10ms p95.","title":"P50, P95, P99"},{"location":"appendix/glossary/#throughput","text":"The number of requests processed per second. In Sentinel MCP: Target: 1000+ policy checks/second per instance.","title":"Throughput"},{"location":"appendix/glossary/#latency","text":"The time taken to process a request. In Sentinel MCP: Policy check adds < 10ms typically. Need more terms? Check the full documentation or open an issue on GitHub.","title":"Latency"},{"location":"governance/executive/","text":"Executive Brief: Governance for AI Agents \u26a0\ufe0f Project Context: This documentation describes a personal R&D exploration project. This is not a commercial product and I am not seeking to develop this into a product . The executive brief is provided for educational purposes to illustrate governance concepts for AI agents. The AI Agent Revolution Is Here 2024 marked a turning point. AI agents moved from demos to production. ChatGPT Actions, Claude Tools, and autonomous agent frameworks are being deployed across enterprises. These agents can: \ud83d\udd0d Search the web autonomously \ud83d\udce7 Send emails and messages \ud83d\udcb0 Make API calls to external services \ud83d\udcca Access databases and internal systems \ud83e\udd16 Execute code and run scripts The question is: Who's in control? The Problem: Governance Gap What Happens Without Governance? Real-world scenarios organizations face today: Runaway Costs An agent makes 10,000 API calls in minutes, exceeding monthly budget No alerting system catches it until the bill arrives Impact: Unexpected six-figure cloud bills Security Breaches An agent accesses sensitive customer data without proper authorization The breach isn't discovered until weeks later Impact: Compliance violations, reputation damage, legal liability Compliance Failures During an audit, you can't prove which actions were authorized Logs are incomplete or unreliable Impact: Failed compliance audits, regulatory fines Tool Sprawl Teams deploy agents without coordination No central inventory of what tools agents can access Impact: Shadow IT, security blind spots, cost overruns Why Traditional Security Models Fail Agents aren't human users. You can't: - \u274c Train them like employees - \u274c Trust them to follow policies - \u274c Rely on their judgment - \u274c Scale security reviews linearly Agents are: - \ud83d\ude80 Autonomous and unpredictable - \ud83d\udcc8 Infinitely scalable - \u26a1 Sub-second decision makers - \ud83d\udd04 Constantly evolving You need runtime governance that sits between agents and tools, enforcing policies at the moment of decision. The Solution: Sentinel MCP Sentinel MCP provides a control plane for AI agents \u2014a centralized system that governs every tool access request. Core Value Propositions 1. \ud83d\udee1\ufe0f Security Through Policy Enforcement What it does: - Every tool access request is evaluated against policies - Policies consider identity, purpose, quotas, and context - Deny-by-default means tools are blocked unless explicitly allowed Business value: - Prevent unauthorized access before it happens - Reduce security incidents by orders of magnitude - Meet compliance requirements through policy enforcement Example: A policy prevents agents from accessing customer PII unless the request comes from an approved purpose and the agent has proper authorization. 2. \ud83d\udcb0 Cost Control Through Quota Management What it does: - Enforces spending limits per tool, per tenant, per time period - Blocks requests when quotas are exceeded - Provides real-time visibility into usage Business value: - Prevent budget overruns from runaway agent usage - Enable chargeback by tracking usage per team - Optimize costs by identifying waste Example: A policy limits GPT-4 API calls to 1,000 per day per team. When exceeded, requests are denied with clear messaging. 3. \ud83d\udea8 Instant Response Through Kill Switch What it does: - Disables tools system-wide in seconds - Revokes credentials automatically - Prevents further tool invocations immediately Business value: - Respond to incidents immediately (target: < 5 seconds) - Reduce breach impact by stopping malicious activity fast - Enable safe experimentation knowing you can stop instantly Example: A security team detects suspicious activity. They trigger the kill switch, disabling the compromised tool across all agents instantly. 4. \ud83d\udccb Compliance Through Provenance Tracking What it does: - Creates cryptographic proof of every action - Signs manifests with non-repudiation - Provides complete audit trails Business value: - Pass compliance audits with verifiable proof - Demonstrate due diligence to regulators - Enable forensic investigations with complete trails Example: During a SOC 2 audit, auditors request proof of actions. Provenance manifests provide cryptographic proof of authorized actions only. 5. \ud83d\udcca Visibility Through Centralized Inventory What it does: - Maintains a single source of truth for all tools - Tracks ownership, health, and usage - Provides dashboards and reporting Business value: - Eliminate shadow IT by discovering all tools - Enable governance through visibility - Optimize operations through usage insights Example: A CISO discovers teams are using unauthorized tools. Sentinel MCP's inventory reveals all tools, enabling proper governance. Adoption Roadmap Phase 1: Discovery (Weeks 1-2) Goal: Understand your current state Activities: - Inventory existing tools and agents - Map current access patterns - Identify high-risk areas - Document existing policies (written or implicit) Deliverables: - Complete tool inventory - Risk assessment - Policy gap analysis Success metrics: - 100% of tools inventoried - Risk areas identified - Quick wins identified Phase 2: Pilot (Weeks 3-6) Goal: Prove value with a single use case Activities: - Deploy Sentinel MCP in pilot environment - Select one team/tool for initial rollout - Write initial policies - Integrate with one agent framework - Run kill-switch drills Deliverables: - Working pilot deployment - Initial policy set - Integration with one agent framework - Kill-switch demonstration Success metrics: - Policy violations caught - Kill-switch MTTR < 5 seconds - Positive feedback from pilot team Phase 3: Expansion (Weeks 7-12) Goal: Scale to enterprise-wide deployment Activities: - Expand to additional teams - Integrate with all agent frameworks - Refine policies based on learnings - Establish governance processes - Train operations teams Deliverables: - Multi-team deployment - Complete framework coverage - Mature policy library - Operations runbooks - Training materials Success metrics: - 80%+ of tools under governance - Policy violations declining - Positive ROI demonstrated Phase 4: Optimization (Ongoing) Goal: Continuous improvement Activities: - Refine policies based on data - Optimize quota allocations - Expand provenance requirements - Enhance observability - Automate governance processes Deliverables: - Optimized policies - Automated governance - Enhanced reporting - Cost optimization Success metrics: - Policy violations near zero - Costs optimized - Compliance maintained Key Metrics to Track Security Metrics Metric Target Why It Matters Policy violations prevented Track baseline Measures security effectiveness Kill-switch MTTR < 5 seconds Measures incident response speed Tools under governance 100% Measures coverage Unauthorized access attempts Track baseline Measures threat landscape Cost Metrics Metric Target Why It Matters Budget overruns prevented Track incidents Measures cost control Cost per action Track baseline Measures efficiency Quota utilization 70-90% Measures optimization Chargeback accuracy 100% Measures attribution Compliance Metrics Metric Target Why It Matters Actions with provenance 100% Measures auditability Audit trail completeness 100% Measures compliance readiness Policy review cycle Quarterly Measures governance maturity Compliance audit success 100% Measures effectiveness ROI Considerations Cost Avoidance Without Sentinel MCP: - Security incidents: $100K+ per incident - Compliance failures: $50K+ per audit failure - Budget overruns: Variable, often $10K-$100K+ With Sentinel MCP: - Prevent security incidents through policy enforcement - Pass compliance audits with provenance tracking - Avoid budget overruns through quota management Time Savings Without Sentinel MCP: - Manual tool reviews: Hours per tool - Incident response: Hours to days - Compliance audits: Weeks of preparation With Sentinel MCP: - Automated policy enforcement: Near-zero manual effort - Instant kill-switch: Seconds instead of hours - Automated audit trails: Days instead of weeks Risk Reduction Without Sentinel MCP: - Unknown risk exposure - Manual controls prone to error - Compliance gaps With Sentinel MCP: - Measurable risk reduction - Automated controls - Compliance-ready Business Case Summary Investment: - Development: 2-4 weeks for pilot - Deployment: 1-2 weeks - Ongoing operations: < 0.5 FTE Returns: - Security: Prevent incidents worth $100K+ - Compliance: Pass audits, avoid fines - Cost: Prevent overruns worth $10K-$100K+ - Operations: Hours saved per week Payback Period: Typically < 3 months Next Steps Week 1: Review this brief with leadership Week 2: Identify pilot team and use case Week 3: Begin Phase 1 (Discovery) Week 4: Plan Phase 2 (Pilot) Questions to answer: - Which team should pilot first? - What are the highest-risk tools/agents? - What compliance requirements must we meet? - What budget thresholds matter most? Conclusion AI agents are here to stay. They're transforming how we work, but they require new governance models. Traditional security approaches don't work for autonomous systems. Sentinel MCP explores: - Runtime governance patterns for AI agents - Policy-driven security and compliance approaches - Instant incident response mechanisms - Complete auditability capabilities Note: This is a personal R&D project exploring these concepts. The architecture and approaches discussed here are shared for educational and research purposes to advance understanding of AI agent governance. Note on Project Status: This is a personal research project, not a commercial offering. The concepts and implementations are shared for learning and exploration. See the Setup Guide for technical implementation details, or the Policy Playbook for policy development concepts.","title":"Executive Brief"},{"location":"governance/executive/#executive-brief-governance-for-ai-agents","text":"\u26a0\ufe0f Project Context: This documentation describes a personal R&D exploration project. This is not a commercial product and I am not seeking to develop this into a product . The executive brief is provided for educational purposes to illustrate governance concepts for AI agents.","title":"Executive Brief: Governance for AI Agents"},{"location":"governance/executive/#the-ai-agent-revolution-is-here","text":"2024 marked a turning point. AI agents moved from demos to production. ChatGPT Actions, Claude Tools, and autonomous agent frameworks are being deployed across enterprises. These agents can: \ud83d\udd0d Search the web autonomously \ud83d\udce7 Send emails and messages \ud83d\udcb0 Make API calls to external services \ud83d\udcca Access databases and internal systems \ud83e\udd16 Execute code and run scripts The question is: Who's in control?","title":"The AI Agent Revolution Is Here"},{"location":"governance/executive/#the-problem-governance-gap","text":"","title":"The Problem: Governance Gap"},{"location":"governance/executive/#what-happens-without-governance","text":"Real-world scenarios organizations face today: Runaway Costs An agent makes 10,000 API calls in minutes, exceeding monthly budget No alerting system catches it until the bill arrives Impact: Unexpected six-figure cloud bills Security Breaches An agent accesses sensitive customer data without proper authorization The breach isn't discovered until weeks later Impact: Compliance violations, reputation damage, legal liability Compliance Failures During an audit, you can't prove which actions were authorized Logs are incomplete or unreliable Impact: Failed compliance audits, regulatory fines Tool Sprawl Teams deploy agents without coordination No central inventory of what tools agents can access Impact: Shadow IT, security blind spots, cost overruns","title":"What Happens Without Governance?"},{"location":"governance/executive/#why-traditional-security-models-fail","text":"Agents aren't human users. You can't: - \u274c Train them like employees - \u274c Trust them to follow policies - \u274c Rely on their judgment - \u274c Scale security reviews linearly Agents are: - \ud83d\ude80 Autonomous and unpredictable - \ud83d\udcc8 Infinitely scalable - \u26a1 Sub-second decision makers - \ud83d\udd04 Constantly evolving You need runtime governance that sits between agents and tools, enforcing policies at the moment of decision.","title":"Why Traditional Security Models Fail"},{"location":"governance/executive/#the-solution-sentinel-mcp","text":"Sentinel MCP provides a control plane for AI agents \u2014a centralized system that governs every tool access request.","title":"The Solution: Sentinel MCP"},{"location":"governance/executive/#core-value-propositions","text":"","title":"Core Value Propositions"},{"location":"governance/executive/#1-security-through-policy-enforcement","text":"What it does: - Every tool access request is evaluated against policies - Policies consider identity, purpose, quotas, and context - Deny-by-default means tools are blocked unless explicitly allowed Business value: - Prevent unauthorized access before it happens - Reduce security incidents by orders of magnitude - Meet compliance requirements through policy enforcement Example: A policy prevents agents from accessing customer PII unless the request comes from an approved purpose and the agent has proper authorization.","title":"1. \ud83d\udee1\ufe0f Security Through Policy Enforcement"},{"location":"governance/executive/#2-cost-control-through-quota-management","text":"What it does: - Enforces spending limits per tool, per tenant, per time period - Blocks requests when quotas are exceeded - Provides real-time visibility into usage Business value: - Prevent budget overruns from runaway agent usage - Enable chargeback by tracking usage per team - Optimize costs by identifying waste Example: A policy limits GPT-4 API calls to 1,000 per day per team. When exceeded, requests are denied with clear messaging.","title":"2. \ud83d\udcb0 Cost Control Through Quota Management"},{"location":"governance/executive/#3-instant-response-through-kill-switch","text":"What it does: - Disables tools system-wide in seconds - Revokes credentials automatically - Prevents further tool invocations immediately Business value: - Respond to incidents immediately (target: < 5 seconds) - Reduce breach impact by stopping malicious activity fast - Enable safe experimentation knowing you can stop instantly Example: A security team detects suspicious activity. They trigger the kill switch, disabling the compromised tool across all agents instantly.","title":"3. \ud83d\udea8 Instant Response Through Kill Switch"},{"location":"governance/executive/#4-compliance-through-provenance-tracking","text":"What it does: - Creates cryptographic proof of every action - Signs manifests with non-repudiation - Provides complete audit trails Business value: - Pass compliance audits with verifiable proof - Demonstrate due diligence to regulators - Enable forensic investigations with complete trails Example: During a SOC 2 audit, auditors request proof of actions. Provenance manifests provide cryptographic proof of authorized actions only.","title":"4. \ud83d\udccb Compliance Through Provenance Tracking"},{"location":"governance/executive/#5-visibility-through-centralized-inventory","text":"What it does: - Maintains a single source of truth for all tools - Tracks ownership, health, and usage - Provides dashboards and reporting Business value: - Eliminate shadow IT by discovering all tools - Enable governance through visibility - Optimize operations through usage insights Example: A CISO discovers teams are using unauthorized tools. Sentinel MCP's inventory reveals all tools, enabling proper governance.","title":"5. \ud83d\udcca Visibility Through Centralized Inventory"},{"location":"governance/executive/#adoption-roadmap","text":"","title":"Adoption Roadmap"},{"location":"governance/executive/#phase-1-discovery-weeks-1-2","text":"Goal: Understand your current state Activities: - Inventory existing tools and agents - Map current access patterns - Identify high-risk areas - Document existing policies (written or implicit) Deliverables: - Complete tool inventory - Risk assessment - Policy gap analysis Success metrics: - 100% of tools inventoried - Risk areas identified - Quick wins identified","title":"Phase 1: Discovery (Weeks 1-2)"},{"location":"governance/executive/#phase-2-pilot-weeks-3-6","text":"Goal: Prove value with a single use case Activities: - Deploy Sentinel MCP in pilot environment - Select one team/tool for initial rollout - Write initial policies - Integrate with one agent framework - Run kill-switch drills Deliverables: - Working pilot deployment - Initial policy set - Integration with one agent framework - Kill-switch demonstration Success metrics: - Policy violations caught - Kill-switch MTTR < 5 seconds - Positive feedback from pilot team","title":"Phase 2: Pilot (Weeks 3-6)"},{"location":"governance/executive/#phase-3-expansion-weeks-7-12","text":"Goal: Scale to enterprise-wide deployment Activities: - Expand to additional teams - Integrate with all agent frameworks - Refine policies based on learnings - Establish governance processes - Train operations teams Deliverables: - Multi-team deployment - Complete framework coverage - Mature policy library - Operations runbooks - Training materials Success metrics: - 80%+ of tools under governance - Policy violations declining - Positive ROI demonstrated","title":"Phase 3: Expansion (Weeks 7-12)"},{"location":"governance/executive/#phase-4-optimization-ongoing","text":"Goal: Continuous improvement Activities: - Refine policies based on data - Optimize quota allocations - Expand provenance requirements - Enhance observability - Automate governance processes Deliverables: - Optimized policies - Automated governance - Enhanced reporting - Cost optimization Success metrics: - Policy violations near zero - Costs optimized - Compliance maintained","title":"Phase 4: Optimization (Ongoing)"},{"location":"governance/executive/#key-metrics-to-track","text":"","title":"Key Metrics to Track"},{"location":"governance/executive/#security-metrics","text":"Metric Target Why It Matters Policy violations prevented Track baseline Measures security effectiveness Kill-switch MTTR < 5 seconds Measures incident response speed Tools under governance 100% Measures coverage Unauthorized access attempts Track baseline Measures threat landscape","title":"Security Metrics"},{"location":"governance/executive/#cost-metrics","text":"Metric Target Why It Matters Budget overruns prevented Track incidents Measures cost control Cost per action Track baseline Measures efficiency Quota utilization 70-90% Measures optimization Chargeback accuracy 100% Measures attribution","title":"Cost Metrics"},{"location":"governance/executive/#compliance-metrics","text":"Metric Target Why It Matters Actions with provenance 100% Measures auditability Audit trail completeness 100% Measures compliance readiness Policy review cycle Quarterly Measures governance maturity Compliance audit success 100% Measures effectiveness","title":"Compliance Metrics"},{"location":"governance/executive/#roi-considerations","text":"","title":"ROI Considerations"},{"location":"governance/executive/#cost-avoidance","text":"Without Sentinel MCP: - Security incidents: $100K+ per incident - Compliance failures: $50K+ per audit failure - Budget overruns: Variable, often $10K-$100K+ With Sentinel MCP: - Prevent security incidents through policy enforcement - Pass compliance audits with provenance tracking - Avoid budget overruns through quota management","title":"Cost Avoidance"},{"location":"governance/executive/#time-savings","text":"Without Sentinel MCP: - Manual tool reviews: Hours per tool - Incident response: Hours to days - Compliance audits: Weeks of preparation With Sentinel MCP: - Automated policy enforcement: Near-zero manual effort - Instant kill-switch: Seconds instead of hours - Automated audit trails: Days instead of weeks","title":"Time Savings"},{"location":"governance/executive/#risk-reduction","text":"Without Sentinel MCP: - Unknown risk exposure - Manual controls prone to error - Compliance gaps With Sentinel MCP: - Measurable risk reduction - Automated controls - Compliance-ready","title":"Risk Reduction"},{"location":"governance/executive/#business-case-summary","text":"Investment: - Development: 2-4 weeks for pilot - Deployment: 1-2 weeks - Ongoing operations: < 0.5 FTE Returns: - Security: Prevent incidents worth $100K+ - Compliance: Pass audits, avoid fines - Cost: Prevent overruns worth $10K-$100K+ - Operations: Hours saved per week Payback Period: Typically < 3 months","title":"Business Case Summary"},{"location":"governance/executive/#next-steps","text":"Week 1: Review this brief with leadership Week 2: Identify pilot team and use case Week 3: Begin Phase 1 (Discovery) Week 4: Plan Phase 2 (Pilot) Questions to answer: - Which team should pilot first? - What are the highest-risk tools/agents? - What compliance requirements must we meet? - What budget thresholds matter most?","title":"Next Steps"},{"location":"governance/executive/#conclusion","text":"AI agents are here to stay. They're transforming how we work, but they require new governance models. Traditional security approaches don't work for autonomous systems. Sentinel MCP explores: - Runtime governance patterns for AI agents - Policy-driven security and compliance approaches - Instant incident response mechanisms - Complete auditability capabilities Note: This is a personal R&D project exploring these concepts. The architecture and approaches discussed here are shared for educational and research purposes to advance understanding of AI agent governance. Note on Project Status: This is a personal research project, not a commercial offering. The concepts and implementations are shared for learning and exploration. See the Setup Guide for technical implementation details, or the Policy Playbook for policy development concepts.","title":"Conclusion"},{"location":"governance/policy-playbook/","text":"Policy Playbook Core policy primitives Allow/Deny rules \u2013 map tenant + tool + purpose to permitted actions. Quotas \u2013 limit usage per tool/team (token count, invocations per minute). Scoped secrets \u2013 ensure tool credentials are only injected when policy allows (future integration with Vault). Kill overrides \u2013 emergency disable irrespective of policy (manual trigger or automated via detection systems). Sample policies (Rego snippets) package sentinel.policy default allow := false allow { allowed_tool within_quota purpose_ok } allowed_tool { data.allowlist[input.tenant][input.tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose == data.required_purpose[input.tenant][input.tool] } Playbook scenarios Scenario Policy action Follow-up Budget exceeded Deny, emit quota exceeded reason Notify FinOps, review quotas Unapproved purpose Deny, require ticket for new purpose Governance review Emergency disable Manual kill switch + audit log Incident response Tool onboarding Add to allowlist , define scopes, run seed script Owner sign-off Governance cadence Weekly policy review stand-up (Platform Eng + AppSec). Monthly metrics dashboard (violations, kills, provenance coverage). Quarterly tabletop exercise for kill-switch drills and provenance audits.","title":"Policy Playbook"},{"location":"governance/policy-playbook/#policy-playbook","text":"","title":"Policy Playbook"},{"location":"governance/policy-playbook/#core-policy-primitives","text":"Allow/Deny rules \u2013 map tenant + tool + purpose to permitted actions. Quotas \u2013 limit usage per tool/team (token count, invocations per minute). Scoped secrets \u2013 ensure tool credentials are only injected when policy allows (future integration with Vault). Kill overrides \u2013 emergency disable irrespective of policy (manual trigger or automated via detection systems).","title":"Core policy primitives"},{"location":"governance/policy-playbook/#sample-policies-rego-snippets","text":"package sentinel.policy default allow := false allow { allowed_tool within_quota purpose_ok } allowed_tool { data.allowlist[input.tenant][input.tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose == data.required_purpose[input.tenant][input.tool] }","title":"Sample policies (Rego snippets)"},{"location":"governance/policy-playbook/#playbook-scenarios","text":"Scenario Policy action Follow-up Budget exceeded Deny, emit quota exceeded reason Notify FinOps, review quotas Unapproved purpose Deny, require ticket for new purpose Governance review Emergency disable Manual kill switch + audit log Incident response Tool onboarding Add to allowlist , define scopes, run seed script Owner sign-off","title":"Playbook scenarios"},{"location":"governance/policy-playbook/#governance-cadence","text":"Weekly policy review stand-up (Platform Eng + AppSec). Monthly metrics dashboard (violations, kills, provenance coverage). Quarterly tabletop exercise for kill-switch drills and provenance audits.","title":"Governance cadence"},{"location":"operations/runbooks/","text":"Operations Runbooks 1. Control plane health check fails Symptoms: /healthz returns non-200, agents report tool registry unavailable. docker compose ps (or orchestrator equivalent) \u2013 ensure control-plane/OPA/Postgres are running. Check structlog output for control_plane.startup errors. Run alembic current to verify database migrations. Re-run make seed to validate registry operations. If OPA unreachable, inspect opa container logs or policy bundle path. 2. Policy denies expected action Query recent policy log via database ( SELECT decision, reason FROM policy_logs ORDER BY created_at DESC LIMIT 10 ). Run pytest tests/unit/test_policy_route.py::test_policy_check_deny to ensure deny flow behaves. Verify OPA data ( opa eval --data opa/data.json --input <input.json> 'data.sentinel.policy' ). Update policies (Rego) and redeploy bundle. 3. Kill switch stuck (tool remains disabled) Check structlog events kill_switch.disabled and kill_switch.restored . Confirm adapters acknowledged disable (AgentKit logs, LangGraph middleware). Run curl /register?tenant_slug=... to confirm is_active status. Use /kill/restore endpoint or Admin UI enable button. If tool remains disabled, inspect adapter credentials and cached tokens; rotate secrets via Vault. 4. Provenance verification failure Use new manifest viewer ( npm run dev -> UI) or CLI: curl /provenance/verify/<id> . Compare manifest payload vs expected action; confirm timestamp/time skew. If signature mismatch, check signing key rotation; update .env SIGNING_KEY and redeploy. Consider re-signing using Sigstore when production signer introduced. 5. Seeding script fails Ensure stack is running: docker compose up -d . Seed script now waits for /healthz ; review logs for Control plane health check failed . Validate environment variables ( POSTGRES_PASSWORD , OPA_URL ). Run pytest tests/api/test_control_plane.py against live stack to reproduce. Escalation & notifications Structured logs: forward to SIEM/Observability stack to trigger alerts on kill_switch.* events. Add future webhook integration to notify Slack/PagerDuty on kill/restore operations. 6. Chaos drill (kill/restore) Ensure the stack is running ( ./scripts/dev_up.sh ). Execute make chaos (invokes hostname_check.sh + chaos_kill.sh ) or run ./scripts/chaos_kill.sh [options] <tenant> <tool> manually ( --cycles , --delay , --jitter , --log ). Monitor logs for kill_switch.disabled / kill_switch.restored and corresponding OTel spans. Verify tool state via /register?tenant_slug=... and the Admin console. Review provenance manifests and policy logs covering the drill window. NOTE: Local chaos drill automation ( make chaos , etc.) is configured for developer machines. Do not run in shared staging/production environments without approval.","title":"Runbooks"},{"location":"operations/runbooks/#operations-runbooks","text":"","title":"Operations Runbooks"},{"location":"operations/runbooks/#1-control-plane-health-check-fails","text":"Symptoms: /healthz returns non-200, agents report tool registry unavailable. docker compose ps (or orchestrator equivalent) \u2013 ensure control-plane/OPA/Postgres are running. Check structlog output for control_plane.startup errors. Run alembic current to verify database migrations. Re-run make seed to validate registry operations. If OPA unreachable, inspect opa container logs or policy bundle path.","title":"1. Control plane health check fails"},{"location":"operations/runbooks/#2-policy-denies-expected-action","text":"Query recent policy log via database ( SELECT decision, reason FROM policy_logs ORDER BY created_at DESC LIMIT 10 ). Run pytest tests/unit/test_policy_route.py::test_policy_check_deny to ensure deny flow behaves. Verify OPA data ( opa eval --data opa/data.json --input <input.json> 'data.sentinel.policy' ). Update policies (Rego) and redeploy bundle.","title":"2. Policy denies expected action"},{"location":"operations/runbooks/#3-kill-switch-stuck-tool-remains-disabled","text":"Check structlog events kill_switch.disabled and kill_switch.restored . Confirm adapters acknowledged disable (AgentKit logs, LangGraph middleware). Run curl /register?tenant_slug=... to confirm is_active status. Use /kill/restore endpoint or Admin UI enable button. If tool remains disabled, inspect adapter credentials and cached tokens; rotate secrets via Vault.","title":"3. Kill switch stuck (tool remains disabled)"},{"location":"operations/runbooks/#4-provenance-verification-failure","text":"Use new manifest viewer ( npm run dev -> UI) or CLI: curl /provenance/verify/<id> . Compare manifest payload vs expected action; confirm timestamp/time skew. If signature mismatch, check signing key rotation; update .env SIGNING_KEY and redeploy. Consider re-signing using Sigstore when production signer introduced.","title":"4. Provenance verification failure"},{"location":"operations/runbooks/#5-seeding-script-fails","text":"Ensure stack is running: docker compose up -d . Seed script now waits for /healthz ; review logs for Control plane health check failed . Validate environment variables ( POSTGRES_PASSWORD , OPA_URL ). Run pytest tests/api/test_control_plane.py against live stack to reproduce.","title":"5. Seeding script fails"},{"location":"operations/runbooks/#escalation-notifications","text":"Structured logs: forward to SIEM/Observability stack to trigger alerts on kill_switch.* events. Add future webhook integration to notify Slack/PagerDuty on kill/restore operations.","title":"Escalation &amp; notifications"},{"location":"operations/runbooks/#6-chaos-drill-killrestore","text":"Ensure the stack is running ( ./scripts/dev_up.sh ). Execute make chaos (invokes hostname_check.sh + chaos_kill.sh ) or run ./scripts/chaos_kill.sh [options] <tenant> <tool> manually ( --cycles , --delay , --jitter , --log ). Monitor logs for kill_switch.disabled / kill_switch.restored and corresponding OTel spans. Verify tool state via /register?tenant_slug=... and the Admin console. Review provenance manifests and policy logs covering the drill window. NOTE: Local chaos drill automation ( make chaos , etc.) is configured for developer machines. Do not run in shared staging/production environments without approval.","title":"6. Chaos drill (kill/restore)"},{"location":"operations/security/","text":"Security & Compliance Guidance Threat model highlights Unauthorized tool invocation: mitigated by policy enforcement at the control plane with deny-by-default rules and purpose checks. Compromised adapter credentials: kill-switch immediately disables tools and provenance manifests provide forensic trail. Policy bypass via prompt injection: guardrails sit between agent and tool, enforcing policies irrespective of prompt content. Provenance tampering: manifests are signed; move to Sigstore or KMS-backed signing for production. Controls in place Per-tool activation state ( is_active ) with rapid kill/restore flow. Rate/usage data captured in policy client (future: move to Redis counters for rate limiting). Structured logging with tenant/tool context for auditing. Signed manifests for every approved action (+ verification endpoint & UI). Recommended hardening Secrets management: move SIGNING_KEY , database credentials, and API tokens to Vault; rotate on a schedule. TLS everywhere: enforce TLS for OPA, Postgres, Redis; pin certificates in adapters. Sigstore integration: replace hash-only signer with sigstore library, store Rekor entries. OPA policy reviews: maintain policy-as-code repo with PR reviews and automated unit tests (rego, conftest). Dependency updates: rely on Dependabot/renovate; treat critical advisories as break-glass. Static analysis: add Bandit ( bandit -r apps/control-plane/src ) and ESLint security rules. Authentication/authorization: add API keys or OIDC tokens for control plane endpoints before production. Compliance pointers Audit logging: send kill_switch.* and policy decision logs to SIEM for retention & analytics. Data retention: configure Postgres retention policy for policy logs (e.g., 180 days) respecting privacy requirements. PII handling: tool metadata should avoid sensitive data; if necessary, pseudonymize owner fields. Access control: restrict who can trigger /kill and /kill/restore via RBAC (future feature). Incident response checklist Trigger kill-switch for impacted tool/tenant. Export provenance manifests for incident window. Audit policy logs for suspicious denies/allow events. Rotate secrets and redeploy adapters. Produce post-incident report using docs in Governance section.","title":"Security & Compliance"},{"location":"operations/security/#security-compliance-guidance","text":"","title":"Security &amp; Compliance Guidance"},{"location":"operations/security/#threat-model-highlights","text":"Unauthorized tool invocation: mitigated by policy enforcement at the control plane with deny-by-default rules and purpose checks. Compromised adapter credentials: kill-switch immediately disables tools and provenance manifests provide forensic trail. Policy bypass via prompt injection: guardrails sit between agent and tool, enforcing policies irrespective of prompt content. Provenance tampering: manifests are signed; move to Sigstore or KMS-backed signing for production.","title":"Threat model highlights"},{"location":"operations/security/#controls-in-place","text":"Per-tool activation state ( is_active ) with rapid kill/restore flow. Rate/usage data captured in policy client (future: move to Redis counters for rate limiting). Structured logging with tenant/tool context for auditing. Signed manifests for every approved action (+ verification endpoint & UI).","title":"Controls in place"},{"location":"operations/security/#recommended-hardening","text":"Secrets management: move SIGNING_KEY , database credentials, and API tokens to Vault; rotate on a schedule. TLS everywhere: enforce TLS for OPA, Postgres, Redis; pin certificates in adapters. Sigstore integration: replace hash-only signer with sigstore library, store Rekor entries. OPA policy reviews: maintain policy-as-code repo with PR reviews and automated unit tests (rego, conftest). Dependency updates: rely on Dependabot/renovate; treat critical advisories as break-glass. Static analysis: add Bandit ( bandit -r apps/control-plane/src ) and ESLint security rules. Authentication/authorization: add API keys or OIDC tokens for control plane endpoints before production.","title":"Recommended hardening"},{"location":"operations/security/#compliance-pointers","text":"Audit logging: send kill_switch.* and policy decision logs to SIEM for retention & analytics. Data retention: configure Postgres retention policy for policy logs (e.g., 180 days) respecting privacy requirements. PII handling: tool metadata should avoid sensitive data; if necessary, pseudonymize owner fields. Access control: restrict who can trigger /kill and /kill/restore via RBAC (future feature).","title":"Compliance pointers"},{"location":"operations/security/#incident-response-checklist","text":"Trigger kill-switch for impacted tool/tenant. Export provenance manifests for incident window. Audit policy logs for suspicious denies/allow events. Rotate secrets and redeploy adapters. Produce post-incident report using docs in Governance section.","title":"Incident response checklist"},{"location":"technical/architecture/","text":"Architecture Deep Dive The Big Picture Sentinel MCP implements a control plane architecture \u2014a centralized system that sits between AI agents and the tools they want to use. This design pattern is essential for governing autonomous systems where you can't rely on traditional perimeter security. Why a control plane? - Centralized governance \u2013 One place to enforce policies - Consistent behavior \u2013 Same rules apply everywhere - Complete visibility \u2013 All decisions logged and auditable - Instant control \u2013 Kill switches work system-wide High-Level Flow When an AI agent wants to use a tool, here's what happens: 1. Agent \u2192 Adapter: \"I want to call tool X\" 2. Adapter \u2192 Control Plane: \"Check if this is allowed\" 3. Control Plane \u2192 Policy Engine: \"Evaluate policy\" 4. Policy Engine \u2192 Control Plane: \"Allow/Deny + reasoning\" 5. Control Plane \u2192 Adapter: \"Decision\" 6. If allowed: - Adapter \u2192 Agent: \"Proceed\" - Adapter \u2192 Control Plane: \"Sign this action\" - Control Plane \u2192 Provenance: \"Create manifest\" 7. If denied: - Adapter \u2192 Agent: \"Blocked: [reason]\" - Control Plane \u2192 Audit Log: \"Denied: [reason]\" Key insight: The agent never talks directly to the tool. Everything flows through the control plane, ensuring governance happens at every step. Component Architecture Control Plane API (FastAPI) Technology: Python 3.11+, FastAPI, SQLAlchemy Responsibilities: - Tool registry and inventory management - Policy evaluation proxy (delegates to OPA) - Kill-switch orchestration - Provenance manifest creation - Audit logging Key Endpoints: - POST /register \u2013 Register a new tool - POST /policy/check \u2013 Request authorization decision - POST /kill \u2013 Disable a tool (kill switch) - POST /kill/restore \u2013 Re-enable a tool - POST /provenance/sign \u2013 Create provenance manifest - GET /provenance/verify/{id} \u2013 Verify a manifest Design decisions: - FastAPI chosen for its async capabilities and automatic OpenAPI docs - SQLAlchemy for database abstraction and migrations - Structlog for structured, queryable logs Database Layer (PostgreSQL) Technology: PostgreSQL 16 Schema highlights: Tenants Table: - id (UUID, primary key) - slug (text, unique) - display_name (text) - created_at (timestamp) Tools Table: - id (UUID, primary key) - tenant_id (UUID, foreign key) - name (text) - url (text) - owner (text) - scopes (JSONB) -- Flexible scopes/metadata - extra_metadata (JSONB) -- Tool-specific data - is_active (boolean) -- Kill switch state - created_at, updated_at (timestamps) Policy Logs Table: - id (UUID, primary key) - tenant_id (UUID, foreign key) - tool_id (UUID, foreign key) - decision (text: \"allow\" | \"deny\") - reason (text) - event_metadata (JSONB) - created_at (timestamp) Why PostgreSQL? - JSONB support \u2013 Flexible metadata storage - ACID compliance \u2013 Critical for audit logs - Mature ecosystem \u2013 Alembic migrations, connection pooling - Production-ready \u2013 Battle-tested at scale Policy Engine (OPA) Technology: Open Policy Agent (OPA) with Rego policies Why OPA? - Policy-as-Code \u2013 Version control, testing, collaboration - Declarative \u2013 Policies describe \"what\" not \"how\" - Language-agnostic \u2013 Works with any system - Fast \u2013 Microsecond evaluation times - Proven \u2013 Used by major tech companies Policy Evaluation Flow: 1. Control Plane receives authorization request 2. Constructs input document: { \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"purpose\": \"documentation_lookup\", \"usage\": 42, \"context\": {...} } 3. Sends to OPA with policy bundle 4. OPA evaluates Rego rules 5. Returns decision + reasoning Sample Policy (Rego): package sentinel.policy default allow := false allow { allowed_tool[input.tool] within_quota purpose_ok } allowed_tool[tool] { data.allowlist[input.tenant][tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose in data.allowed_purposes[input.tenant][input.tool] } OPA Deployment: - Development: Docker Compose sidecar - Production: Kubernetes sidecar or separate service - Policy Updates: GitOps workflow (bundle from Git) Provenance Service Technology: Custom Python module, Sigstore-compatible design What it does: - Creates cryptographically signed manifests - Stores manifests for verification - Provides verification endpoints - Supports C2PA-style provenance Manifest Structure: { \"id\": \"manifest-uuid\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"action\": \"invoke\", \"purpose\": \"documentation_lookup\", \"payload_hash\": \"sha256:...\", \"signature\": \"...\", \"metadata\": {...} } Current implementation: - Uses local signing key ( .env SIGNING_KEY) - Stores manifests in .data/provenance/ - Provides verification endpoint Production target: - Sigstore integration for public-key infrastructure - Immutable storage (S3 + Glacier) - Rekor integration for transparency logs Admin Console (Next.js) Technology: Next.js, React, TypeScript Features: - Tool Inventory \u2013 Browse all registered tools - Kill Switch UI \u2013 One-click disable/enable - Policy Probes \u2013 Test policies before deployment - Manifest Viewer \u2013 Verify provenance manifests Architecture: - Client-side React app - REST API integration with control plane - Real-time updates via polling (future: WebSockets) Deployment: - Development: npm run dev (localhost:3000) - Production: Static export ( npm run build ) \u2192 CDN Agent Adapters Purpose: Bridge between agent frameworks and Sentinel MCP Design Pattern: class Adapter: async def invoke_tool(self, tool_name, params): # 1. Check authorization decision = await control_plane.check_policy(...) if not decision.allow: raise PolicyDenied(decision.reason) # 2. Invoke tool result = await self._actual_tool_call(tool_name, params) # 3. Sign provenance manifest = await control_plane.sign_provenance(...) return result Available Adapters: - AgentKit Adapter ( agentkit_adapter.py ) \u2013 OpenAI AgentKit integration - LangGraph Middleware ( langgraph_middleware.py ) \u2013 LangGraph integration - Claude Skills Hook ( skills_hook.ts ) \u2013 TypeScript hook for Claude Extending: - Implement adapter interface - Handle authorization checks - Sign provenance after actions - Handle kill-switch signals Data Flow: Tool Invocation Sequence sequenceDiagram participant Agent participant Adapter participant ControlPlane participant OPA participant Tool participant Provenance Agent->>Adapter: invoke_tool(\"search\", query) Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy OPA-->>ControlPlane: allow: true, reason: \"within quota\" ControlPlane-->>Adapter: allow: true Adapter->>Tool: Actual API call Tool-->>Adapter: Response Adapter->>ControlPlane: POST /provenance/sign ControlPlane->>Provenance: Create manifest Provenance-->>ControlPlane: manifest_id ControlPlane-->>Adapter: manifest_id Adapter-->>Agent: Result + manifest_id If policy denies: Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy OPA-->>ControlPlane: allow: false, reason: \"quota exceeded\" ControlPlane-->>Adapter: allow: false, reason: \"quota exceeded\" Adapter-->>Agent: PolicyDenied(\"quota exceeded\") Observability & Telemetry Structured Logging (Structlog) What gets logged: - Policy decisions ( policy.check.allow , policy.check.deny ) - Kill-switch events ( kill_switch.disabled , kill_switch.restored ) - Provenance events ( provenance.signed , provenance.verified ) - Errors with full context Log format: { \"event\": \"kill_switch.disabled\", \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"reason\": \"security_incident\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"metadata\": {...} } OpenTelemetry Spans Current implementation: - Wraps kill-switch handlers - Tracks tenant/tool metadata - Measures latency Future expansion: - Policy evaluation spans - Provenance signing spans - Full request tracing - Export to Tempo, Jaeger, or Honeycomb Metrics (Future) Recommended metrics: - Policy check latency (p50, p95, p99) - Kill-switch MTTR - Quota utilization rates - Provenance signing success rate - Error rates by endpoint Deployment Architectures Local Development Stack: docker-compose.dev.yml \u251c\u2500\u2500 postgres:16 \u251c\u2500\u2500 redis:7 \u251c\u2500\u2500 opa (sidecar) \u2514\u2500\u2500 control-plane (FastAPI) Admin Console: Runs separately with npm run dev Pros: - Fast iteration - Easy debugging - Complete isolation Cons: - Not production-like - Single tenant Production Architecture Recommended: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Load Balancer (TLS) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Control Plane \u2502 \u2502 (Kubernetes) \u2502 \u2502 - FastAPI pods \u2502 \u2502 - OPA sidecar \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PostgreSQL \u2502 \u2502 (Managed DB) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Components: - Control Plane: Kubernetes deployment with HPA - Database: Managed PostgreSQL (AWS RDS, GCP Cloud SQL) - Cache: Managed Redis (ElastiCache, Memorystore) - Secrets: Vault or cloud secrets manager - OPA: Sidecar or separate service - Admin Console: Static site on CDN Security: - TLS everywhere - mTLS for service-to-service - Secrets rotation - Network policies - RBAC for Kubernetes Scalability Considerations Horizontal Scaling Control Plane: - Stateless design enables horizontal scaling - Load balancer distributes requests - Database connection pooling OPA: - Stateless evaluation - Can run as sidecar or service - Policy bundles cached in memory Database Scaling Read Replicas: - Policy logs are read-heavy - Use replicas for reporting Partitioning: - Partition policy logs by date - Archive old logs Caching Strategy Redis Usage: - Rate limit counters (future) - Kill-switch broadcast cache (future) - Policy decision cache (future) Security Architecture Defense in Depth Network Layer: TLS, mTLS, network policies Application Layer: Policy enforcement, input validation Data Layer: Encryption at rest, access controls Identity Layer: API keys, OIDC (future) Threat Model Threats mitigated: - \u2705 Unauthorized tool access \u2192 Policy enforcement - \u2705 Compromised credentials \u2192 Kill switch - \u2705 Policy bypass \u2192 Control plane architecture - \u2705 Provenance tampering \u2192 Cryptographic signatures Future enhancements: - Rate limiting at network layer - DDoS protection - Advanced threat detection Performance Characteristics Policy Check Latency: - Target: < 10ms p95 - OPA evaluation: < 1ms typically - Database query: < 5ms typically Kill Switch MTTR: - Target: < 5 seconds - Database update: < 100ms - Adapter notification: < 1s - State propagation: < 5s total Throughput: - Target: 1000+ policy checks/second - Database: Scales with connection pooling - OPA: Scales horizontally Future Architecture Evolution Short-term: - Sigstore integration for provenance - Redis-based rate limiting - WebSocket support for real-time updates Medium-term: - Policy decision caching - Advanced observability (OTel exports) - Terraform modules for cloud deployment Long-term: - Multi-region support - Policy graph with relationships - ML-based anomaly detection Understanding the architecture helps you: - Make informed deployment decisions - Troubleshoot issues effectively - Extend the system confidently - Plan for scale Next: Setup Guide for hands-on deployment.","title":"Architecture"},{"location":"technical/architecture/#architecture-deep-dive","text":"","title":"Architecture Deep Dive"},{"location":"technical/architecture/#the-big-picture","text":"Sentinel MCP implements a control plane architecture \u2014a centralized system that sits between AI agents and the tools they want to use. This design pattern is essential for governing autonomous systems where you can't rely on traditional perimeter security. Why a control plane? - Centralized governance \u2013 One place to enforce policies - Consistent behavior \u2013 Same rules apply everywhere - Complete visibility \u2013 All decisions logged and auditable - Instant control \u2013 Kill switches work system-wide","title":"The Big Picture"},{"location":"technical/architecture/#high-level-flow","text":"When an AI agent wants to use a tool, here's what happens: 1. Agent \u2192 Adapter: \"I want to call tool X\" 2. Adapter \u2192 Control Plane: \"Check if this is allowed\" 3. Control Plane \u2192 Policy Engine: \"Evaluate policy\" 4. Policy Engine \u2192 Control Plane: \"Allow/Deny + reasoning\" 5. Control Plane \u2192 Adapter: \"Decision\" 6. If allowed: - Adapter \u2192 Agent: \"Proceed\" - Adapter \u2192 Control Plane: \"Sign this action\" - Control Plane \u2192 Provenance: \"Create manifest\" 7. If denied: - Adapter \u2192 Agent: \"Blocked: [reason]\" - Control Plane \u2192 Audit Log: \"Denied: [reason]\" Key insight: The agent never talks directly to the tool. Everything flows through the control plane, ensuring governance happens at every step.","title":"High-Level Flow"},{"location":"technical/architecture/#component-architecture","text":"","title":"Component Architecture"},{"location":"technical/architecture/#control-plane-api-fastapi","text":"Technology: Python 3.11+, FastAPI, SQLAlchemy Responsibilities: - Tool registry and inventory management - Policy evaluation proxy (delegates to OPA) - Kill-switch orchestration - Provenance manifest creation - Audit logging Key Endpoints: - POST /register \u2013 Register a new tool - POST /policy/check \u2013 Request authorization decision - POST /kill \u2013 Disable a tool (kill switch) - POST /kill/restore \u2013 Re-enable a tool - POST /provenance/sign \u2013 Create provenance manifest - GET /provenance/verify/{id} \u2013 Verify a manifest Design decisions: - FastAPI chosen for its async capabilities and automatic OpenAPI docs - SQLAlchemy for database abstraction and migrations - Structlog for structured, queryable logs","title":"Control Plane API (FastAPI)"},{"location":"technical/architecture/#database-layer-postgresql","text":"Technology: PostgreSQL 16 Schema highlights: Tenants Table: - id (UUID, primary key) - slug (text, unique) - display_name (text) - created_at (timestamp) Tools Table: - id (UUID, primary key) - tenant_id (UUID, foreign key) - name (text) - url (text) - owner (text) - scopes (JSONB) -- Flexible scopes/metadata - extra_metadata (JSONB) -- Tool-specific data - is_active (boolean) -- Kill switch state - created_at, updated_at (timestamps) Policy Logs Table: - id (UUID, primary key) - tenant_id (UUID, foreign key) - tool_id (UUID, foreign key) - decision (text: \"allow\" | \"deny\") - reason (text) - event_metadata (JSONB) - created_at (timestamp) Why PostgreSQL? - JSONB support \u2013 Flexible metadata storage - ACID compliance \u2013 Critical for audit logs - Mature ecosystem \u2013 Alembic migrations, connection pooling - Production-ready \u2013 Battle-tested at scale","title":"Database Layer (PostgreSQL)"},{"location":"technical/architecture/#policy-engine-opa","text":"Technology: Open Policy Agent (OPA) with Rego policies Why OPA? - Policy-as-Code \u2013 Version control, testing, collaboration - Declarative \u2013 Policies describe \"what\" not \"how\" - Language-agnostic \u2013 Works with any system - Fast \u2013 Microsecond evaluation times - Proven \u2013 Used by major tech companies Policy Evaluation Flow: 1. Control Plane receives authorization request 2. Constructs input document: { \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"purpose\": \"documentation_lookup\", \"usage\": 42, \"context\": {...} } 3. Sends to OPA with policy bundle 4. OPA evaluates Rego rules 5. Returns decision + reasoning Sample Policy (Rego): package sentinel.policy default allow := false allow { allowed_tool[input.tool] within_quota purpose_ok } allowed_tool[tool] { data.allowlist[input.tenant][tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose in data.allowed_purposes[input.tenant][input.tool] } OPA Deployment: - Development: Docker Compose sidecar - Production: Kubernetes sidecar or separate service - Policy Updates: GitOps workflow (bundle from Git)","title":"Policy Engine (OPA)"},{"location":"technical/architecture/#provenance-service","text":"Technology: Custom Python module, Sigstore-compatible design What it does: - Creates cryptographically signed manifests - Stores manifests for verification - Provides verification endpoints - Supports C2PA-style provenance Manifest Structure: { \"id\": \"manifest-uuid\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"action\": \"invoke\", \"purpose\": \"documentation_lookup\", \"payload_hash\": \"sha256:...\", \"signature\": \"...\", \"metadata\": {...} } Current implementation: - Uses local signing key ( .env SIGNING_KEY) - Stores manifests in .data/provenance/ - Provides verification endpoint Production target: - Sigstore integration for public-key infrastructure - Immutable storage (S3 + Glacier) - Rekor integration for transparency logs","title":"Provenance Service"},{"location":"technical/architecture/#admin-console-nextjs","text":"Technology: Next.js, React, TypeScript Features: - Tool Inventory \u2013 Browse all registered tools - Kill Switch UI \u2013 One-click disable/enable - Policy Probes \u2013 Test policies before deployment - Manifest Viewer \u2013 Verify provenance manifests Architecture: - Client-side React app - REST API integration with control plane - Real-time updates via polling (future: WebSockets) Deployment: - Development: npm run dev (localhost:3000) - Production: Static export ( npm run build ) \u2192 CDN","title":"Admin Console (Next.js)"},{"location":"technical/architecture/#agent-adapters","text":"Purpose: Bridge between agent frameworks and Sentinel MCP Design Pattern: class Adapter: async def invoke_tool(self, tool_name, params): # 1. Check authorization decision = await control_plane.check_policy(...) if not decision.allow: raise PolicyDenied(decision.reason) # 2. Invoke tool result = await self._actual_tool_call(tool_name, params) # 3. Sign provenance manifest = await control_plane.sign_provenance(...) return result Available Adapters: - AgentKit Adapter ( agentkit_adapter.py ) \u2013 OpenAI AgentKit integration - LangGraph Middleware ( langgraph_middleware.py ) \u2013 LangGraph integration - Claude Skills Hook ( skills_hook.ts ) \u2013 TypeScript hook for Claude Extending: - Implement adapter interface - Handle authorization checks - Sign provenance after actions - Handle kill-switch signals","title":"Agent Adapters"},{"location":"technical/architecture/#data-flow-tool-invocation-sequence","text":"sequenceDiagram participant Agent participant Adapter participant ControlPlane participant OPA participant Tool participant Provenance Agent->>Adapter: invoke_tool(\"search\", query) Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy OPA-->>ControlPlane: allow: true, reason: \"within quota\" ControlPlane-->>Adapter: allow: true Adapter->>Tool: Actual API call Tool-->>Adapter: Response Adapter->>ControlPlane: POST /provenance/sign ControlPlane->>Provenance: Create manifest Provenance-->>ControlPlane: manifest_id ControlPlane-->>Adapter: manifest_id Adapter-->>Agent: Result + manifest_id If policy denies: Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy OPA-->>ControlPlane: allow: false, reason: \"quota exceeded\" ControlPlane-->>Adapter: allow: false, reason: \"quota exceeded\" Adapter-->>Agent: PolicyDenied(\"quota exceeded\")","title":"Data Flow: Tool Invocation Sequence"},{"location":"technical/architecture/#observability-telemetry","text":"","title":"Observability &amp; Telemetry"},{"location":"technical/architecture/#structured-logging-structlog","text":"What gets logged: - Policy decisions ( policy.check.allow , policy.check.deny ) - Kill-switch events ( kill_switch.disabled , kill_switch.restored ) - Provenance events ( provenance.signed , provenance.verified ) - Errors with full context Log format: { \"event\": \"kill_switch.disabled\", \"tenant\": \"platform-eng\", \"tool\": \"langsmith-docs-search\", \"reason\": \"security_incident\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"metadata\": {...} }","title":"Structured Logging (Structlog)"},{"location":"technical/architecture/#opentelemetry-spans","text":"Current implementation: - Wraps kill-switch handlers - Tracks tenant/tool metadata - Measures latency Future expansion: - Policy evaluation spans - Provenance signing spans - Full request tracing - Export to Tempo, Jaeger, or Honeycomb","title":"OpenTelemetry Spans"},{"location":"technical/architecture/#metrics-future","text":"Recommended metrics: - Policy check latency (p50, p95, p99) - Kill-switch MTTR - Quota utilization rates - Provenance signing success rate - Error rates by endpoint","title":"Metrics (Future)"},{"location":"technical/architecture/#deployment-architectures","text":"","title":"Deployment Architectures"},{"location":"technical/architecture/#local-development","text":"Stack: docker-compose.dev.yml \u251c\u2500\u2500 postgres:16 \u251c\u2500\u2500 redis:7 \u251c\u2500\u2500 opa (sidecar) \u2514\u2500\u2500 control-plane (FastAPI) Admin Console: Runs separately with npm run dev Pros: - Fast iteration - Easy debugging - Complete isolation Cons: - Not production-like - Single tenant","title":"Local Development"},{"location":"technical/architecture/#production-architecture","text":"Recommended: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Load Balancer (TLS) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Control Plane \u2502 \u2502 (Kubernetes) \u2502 \u2502 - FastAPI pods \u2502 \u2502 - OPA sidecar \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PostgreSQL \u2502 \u2502 (Managed DB) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Components: - Control Plane: Kubernetes deployment with HPA - Database: Managed PostgreSQL (AWS RDS, GCP Cloud SQL) - Cache: Managed Redis (ElastiCache, Memorystore) - Secrets: Vault or cloud secrets manager - OPA: Sidecar or separate service - Admin Console: Static site on CDN Security: - TLS everywhere - mTLS for service-to-service - Secrets rotation - Network policies - RBAC for Kubernetes","title":"Production Architecture"},{"location":"technical/architecture/#scalability-considerations","text":"","title":"Scalability Considerations"},{"location":"technical/architecture/#horizontal-scaling","text":"Control Plane: - Stateless design enables horizontal scaling - Load balancer distributes requests - Database connection pooling OPA: - Stateless evaluation - Can run as sidecar or service - Policy bundles cached in memory","title":"Horizontal Scaling"},{"location":"technical/architecture/#database-scaling","text":"Read Replicas: - Policy logs are read-heavy - Use replicas for reporting Partitioning: - Partition policy logs by date - Archive old logs","title":"Database Scaling"},{"location":"technical/architecture/#caching-strategy","text":"Redis Usage: - Rate limit counters (future) - Kill-switch broadcast cache (future) - Policy decision cache (future)","title":"Caching Strategy"},{"location":"technical/architecture/#security-architecture","text":"","title":"Security Architecture"},{"location":"technical/architecture/#defense-in-depth","text":"Network Layer: TLS, mTLS, network policies Application Layer: Policy enforcement, input validation Data Layer: Encryption at rest, access controls Identity Layer: API keys, OIDC (future)","title":"Defense in Depth"},{"location":"technical/architecture/#threat-model","text":"Threats mitigated: - \u2705 Unauthorized tool access \u2192 Policy enforcement - \u2705 Compromised credentials \u2192 Kill switch - \u2705 Policy bypass \u2192 Control plane architecture - \u2705 Provenance tampering \u2192 Cryptographic signatures Future enhancements: - Rate limiting at network layer - DDoS protection - Advanced threat detection","title":"Threat Model"},{"location":"technical/architecture/#performance-characteristics","text":"Policy Check Latency: - Target: < 10ms p95 - OPA evaluation: < 1ms typically - Database query: < 5ms typically Kill Switch MTTR: - Target: < 5 seconds - Database update: < 100ms - Adapter notification: < 1s - State propagation: < 5s total Throughput: - Target: 1000+ policy checks/second - Database: Scales with connection pooling - OPA: Scales horizontally","title":"Performance Characteristics"},{"location":"technical/architecture/#future-architecture-evolution","text":"Short-term: - Sigstore integration for provenance - Redis-based rate limiting - WebSocket support for real-time updates Medium-term: - Policy decision caching - Advanced observability (OTel exports) - Terraform modules for cloud deployment Long-term: - Multi-region support - Policy graph with relationships - ML-based anomaly detection Understanding the architecture helps you: - Make informed deployment decisions - Troubleshoot issues effectively - Extend the system confidently - Plan for scale Next: Setup Guide for hands-on deployment.","title":"Future Architecture Evolution"},{"location":"technical/setup/","text":"Setup & Deployment Prerequisites Python 3.11+ Node 20+ Docker Desktop (or compatible engine) for local compose mkdocs (optional) for building docs: pip install mkdocs Local development Clone and bootstrap bash git clone <repo> cd sentinel-mcp cp .env.example .env # update POSTGRES_PASSWORD, SIGNING_KEY, etc. make install source .venv/bin/activate pytest cd apps/admin-console && npm install && npm run lint && npm run test Bring up the stack bash docker compose -f docker-compose.dev.yml up -d docker compose -f docker-compose.dev.yml exec control-plane alembic upgrade head source ../.venv/bin/activate && make seed Explore the UI bash NEXT_PUBLIC_CONTROL_PLANE_URL=http://localhost:8000 npm run dev Inventory tools, trigger kill switch, re-enable via restore, and verify manifests. Tear down bash docker compose -f docker-compose.dev.yml down Running tests Chaos drill: make chaos CHAOS_CYCLES=3 CHAOS_TENANT=platform-eng CHAOS_TOOL=langsmith-docs-search (override vars as needed). Documentation: make docs-build (build) or make docs-serve (live preview). Running tests Backend unit + integration: pytest API smoke against live control plane: pytest -m e2e (future marker). Frontend: npm run lint && npm run test Docs: mkdocs serve (live preview) or mkdocs build (static output). CI recommendations Lint & format: pre-commit run --all-files Python matrix: pytest with sqlite fallback + docker-compose integration job. Frontend job: install, lint, vitest. Docs job: pip install mkdocs-material then mkdocs build . Security job: pip install bandit and run bandit -r apps/control-plane/src plus npm audit --production . Deployment outline Infrastructure : provision Postgres (with TLS), Redis, Vault or Secrets Manager, and an OPA deployment. Control plane : build container via docker build -f apps/control-plane/Dockerfile . , push to registry. OPA policies : mount Rego bundles via bucket or GitOps. Admin console : build static site ( npm run build ) and host behind CDN. Observability : configure OTLP exporter and structure logs to a centralized log pipeline. Secrets : supply environment variables via Vault injectors or orchestrator secrets. Kill/restore notifications : integrate with Slack/PagerDuty via webhook triggered from Structlog processor or event stream (future work).","title":"Setup & Deployment"},{"location":"technical/setup/#setup-deployment","text":"","title":"Setup &amp; Deployment"},{"location":"technical/setup/#prerequisites","text":"Python 3.11+ Node 20+ Docker Desktop (or compatible engine) for local compose mkdocs (optional) for building docs: pip install mkdocs","title":"Prerequisites"},{"location":"technical/setup/#local-development","text":"Clone and bootstrap bash git clone <repo> cd sentinel-mcp cp .env.example .env # update POSTGRES_PASSWORD, SIGNING_KEY, etc. make install source .venv/bin/activate pytest cd apps/admin-console && npm install && npm run lint && npm run test Bring up the stack bash docker compose -f docker-compose.dev.yml up -d docker compose -f docker-compose.dev.yml exec control-plane alembic upgrade head source ../.venv/bin/activate && make seed Explore the UI bash NEXT_PUBLIC_CONTROL_PLANE_URL=http://localhost:8000 npm run dev Inventory tools, trigger kill switch, re-enable via restore, and verify manifests. Tear down bash docker compose -f docker-compose.dev.yml down","title":"Local development"},{"location":"technical/setup/#running-tests","text":"Chaos drill: make chaos CHAOS_CYCLES=3 CHAOS_TENANT=platform-eng CHAOS_TOOL=langsmith-docs-search (override vars as needed). Documentation: make docs-build (build) or make docs-serve (live preview).","title":"Running tests"},{"location":"technical/setup/#running-tests_1","text":"Backend unit + integration: pytest API smoke against live control plane: pytest -m e2e (future marker). Frontend: npm run lint && npm run test Docs: mkdocs serve (live preview) or mkdocs build (static output).","title":"Running tests"},{"location":"technical/setup/#ci-recommendations","text":"Lint & format: pre-commit run --all-files Python matrix: pytest with sqlite fallback + docker-compose integration job. Frontend job: install, lint, vitest. Docs job: pip install mkdocs-material then mkdocs build . Security job: pip install bandit and run bandit -r apps/control-plane/src plus npm audit --production .","title":"CI recommendations"},{"location":"technical/setup/#deployment-outline","text":"Infrastructure : provision Postgres (with TLS), Redis, Vault or Secrets Manager, and an OPA deployment. Control plane : build container via docker build -f apps/control-plane/Dockerfile . , push to registry. OPA policies : mount Rego bundles via bucket or GitOps. Admin console : build static site ( npm run build ) and host behind CDN. Observability : configure OTLP exporter and structure logs to a centralized log pipeline. Secrets : supply environment variables via Vault injectors or orchestrator secrets. Kill/restore notifications : integrate with Slack/PagerDuty via webhook triggered from Structlog processor or event stream (future work).","title":"Deployment outline"},{"location":"technical/testing/","text":"Testing Strategy Layers Layer Tooling Coverage Unit Pytest, Vitest Business logic, policy client stubs, UI components API Pytest TestClient Policy allow/deny, kill/restore responses Integration (opt-in) docker-compose End-to-end health, seeding, provenance verification UI smoke Vitest + Testing Library (future: Playwright) Kill/restore toggle, manifest verification Chaos (future) custom scripts OPA outage, rate-limit spikes, kill-switch drills Current suites tests/unit/test_policy_client.py : OPA client happy/error paths. tests/unit/test_policy_route.py : allow/deny behaviour without live OPA. tests/unit/test_provenance.py : sign/verify round-trip. tests/unit/test_agentkit_adapter.py : adapter enforces allow before provenance. tests/api/test_control_plane.py : end-to-end register \u2192 policy \u2192 kill/restore \u2192 provenance (skips if control plane not running). Admin console: ToolTable and ManifestViewer components. Recommended additions Database constraint tests (unique tool names, tenant slug case sensitivity). Chaos harness verifying kill-switch MTTR and quota exhaustion. UI e2e using Playwright to exercise full flows. Testing commands source .venv/bin/activate pytest # API smoke (requires stack running) make api-test make coverage cd apps/admin-console npm run lint npm run test Quality gates Branch protection should require backend lint/tests ( pytest ) and frontend lint/tests ( npm run lint && npm run test ). Nightly integration pipeline ( .github/workflows/nightly-e2e.yml ) spins up the compose stack, seeds, and runs the API smoke suite. Dependabot updates must include test runs before merge. Chaos drills Script: ./scripts/chaos_kill.sh [--cycles N] [--delay N] [--jitter N] [--log FILE] <tenant_slug> <tool_name> for quick kill/restore loops. Track structured logs and spans to ensure kill MTTR < 5 seconds. Extend with rate-limit spikes and OPA outage simulations (future).","title":"Testing Strategy"},{"location":"technical/testing/#testing-strategy","text":"","title":"Testing Strategy"},{"location":"technical/testing/#layers","text":"Layer Tooling Coverage Unit Pytest, Vitest Business logic, policy client stubs, UI components API Pytest TestClient Policy allow/deny, kill/restore responses Integration (opt-in) docker-compose End-to-end health, seeding, provenance verification UI smoke Vitest + Testing Library (future: Playwright) Kill/restore toggle, manifest verification Chaos (future) custom scripts OPA outage, rate-limit spikes, kill-switch drills","title":"Layers"},{"location":"technical/testing/#current-suites","text":"tests/unit/test_policy_client.py : OPA client happy/error paths. tests/unit/test_policy_route.py : allow/deny behaviour without live OPA. tests/unit/test_provenance.py : sign/verify round-trip. tests/unit/test_agentkit_adapter.py : adapter enforces allow before provenance. tests/api/test_control_plane.py : end-to-end register \u2192 policy \u2192 kill/restore \u2192 provenance (skips if control plane not running). Admin console: ToolTable and ManifestViewer components.","title":"Current suites"},{"location":"technical/testing/#recommended-additions","text":"Database constraint tests (unique tool names, tenant slug case sensitivity). Chaos harness verifying kill-switch MTTR and quota exhaustion. UI e2e using Playwright to exercise full flows.","title":"Recommended additions"},{"location":"technical/testing/#testing-commands","text":"source .venv/bin/activate pytest # API smoke (requires stack running) make api-test make coverage cd apps/admin-console npm run lint npm run test","title":"Testing commands"},{"location":"technical/testing/#quality-gates","text":"Branch protection should require backend lint/tests ( pytest ) and frontend lint/tests ( npm run lint && npm run test ). Nightly integration pipeline ( .github/workflows/nightly-e2e.yml ) spins up the compose stack, seeds, and runs the API smoke suite. Dependabot updates must include test runs before merge.","title":"Quality gates"},{"location":"technical/testing/#chaos-drills","text":"Script: ./scripts/chaos_kill.sh [--cycles N] [--delay N] [--jitter N] [--log FILE] <tenant_slug> <tool_name> for quick kill/restore loops. Track structured logs and spans to ensure kill MTTR < 5 seconds. Extend with rate-limit spikes and OPA outage simulations (future).","title":"Chaos drills"}]}