{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sentinel MCP Documentation Welcome to the Sentinel MCP knowledge base. This site covers everything from executive overviews to hands-on runbooks so both technical and non-technical stakeholders can navigate the control plane with confidence. Audience guide Executives & risk owners \u2013 focus on the Governance section for the business rationale, adoption plan, and policy playbooks. Platform engineers & security teams \u2013 dive into the Technical Guides for architecture, provisioning, and the testing strategy. Operators & on-call responders \u2013 start with the Operations runbooks and security controls. Quick facts What: Sentinel MCP inventories Model-Context Protocol skills/tools, enforces policies, rate limits, and near-real-time kill switches with signed provenance for every action. Why now: Agent stacks are entering production; unified governance and kill switch capabilities are required to mitigate tool sprawl and audit gaps. Status: Personal R&D build. Expect rapid iteration. Navigate with the sidebar to get started.","title":"Overview"},{"location":"#sentinel-mcp-documentation","text":"Welcome to the Sentinel MCP knowledge base. This site covers everything from executive overviews to hands-on runbooks so both technical and non-technical stakeholders can navigate the control plane with confidence.","title":"Sentinel MCP Documentation"},{"location":"#audience-guide","text":"Executives & risk owners \u2013 focus on the Governance section for the business rationale, adoption plan, and policy playbooks. Platform engineers & security teams \u2013 dive into the Technical Guides for architecture, provisioning, and the testing strategy. Operators & on-call responders \u2013 start with the Operations runbooks and security controls.","title":"Audience guide"},{"location":"#quick-facts","text":"What: Sentinel MCP inventories Model-Context Protocol skills/tools, enforces policies, rate limits, and near-real-time kill switches with signed provenance for every action. Why now: Agent stacks are entering production; unified governance and kill switch capabilities are required to mitigate tool sprawl and audit gaps. Status: Personal R&D build. Expect rapid iteration. Navigate with the sidebar to get started.","title":"Quick facts"},{"location":"appendix/faq/","text":"FAQ Is Sentinel MCP production-ready? No. It is an R&D prototype intended to explore control-plane patterns. Can I use SQLite instead of Postgres? Not currently; the schema relies on Postgres-specific types (JSONB). Future work could add an abstraction for testing. How fast is the kill switch? Local drills complete in milliseconds for state change; adapters must also revoke credentials. Target MTTR is < 5 seconds in production. Where are provenance manifests stored? Locally under .data/provenance . Replace with object storage or immutable logs (S3 + Glacier, append-only database) for production. Do policies support hierarchical budgets? Today only tenant-tool quotas exist. Extend OPA data to include nested budget policies. How is authentication handled? Prototype has no auth. Add API keys/OIDC before exposing outside trusted network. Can I integrate with SIEM/alerts? Yes\u2014structured logs capture kill events. Ship them to your log pipeline; add webhooks for real-time notifications.","title":"FAQ"},{"location":"appendix/faq/#faq","text":"Is Sentinel MCP production-ready? No. It is an R&D prototype intended to explore control-plane patterns. Can I use SQLite instead of Postgres? Not currently; the schema relies on Postgres-specific types (JSONB). Future work could add an abstraction for testing. How fast is the kill switch? Local drills complete in milliseconds for state change; adapters must also revoke credentials. Target MTTR is < 5 seconds in production. Where are provenance manifests stored? Locally under .data/provenance . Replace with object storage or immutable logs (S3 + Glacier, append-only database) for production. Do policies support hierarchical budgets? Today only tenant-tool quotas exist. Extend OPA data to include nested budget policies. How is authentication handled? Prototype has no auth. Add API keys/OIDC before exposing outside trusted network. Can I integrate with SIEM/alerts? Yes\u2014structured logs capture kill events. Ship them to your log pipeline; add webhooks for real-time notifications.","title":"FAQ"},{"location":"appendix/glossary/","text":"Glossary MCP (Model-Context Protocol) \u2013 protocol for agent tools/skills to register capabilities and exchange structured context. OPA (Open Policy Agent) \u2013 policy engine evaluating Rego policies to return allow/deny decisions. Rego \u2013 policy language used by OPA. AgentKit / LangGraph / Claude Skills \u2013 ecosystems for building agent workflows; adapters integrate them with Sentinel MCP. Kill switch \u2013 emergency disable mechanism preventing tools from being invoked. Provenance manifest \u2013 signed record (payload + hash + timestamp) proving what action occurred. Sigstore \u2013 open-source signing infrastructure; future target for production provenance. OTel (OpenTelemetry) \u2013 observability framework for traces/logs/metrics. Structlog \u2013 Python logging library producing structured logs.","title":"Glossary"},{"location":"appendix/glossary/#glossary","text":"MCP (Model-Context Protocol) \u2013 protocol for agent tools/skills to register capabilities and exchange structured context. OPA (Open Policy Agent) \u2013 policy engine evaluating Rego policies to return allow/deny decisions. Rego \u2013 policy language used by OPA. AgentKit / LangGraph / Claude Skills \u2013 ecosystems for building agent workflows; adapters integrate them with Sentinel MCP. Kill switch \u2013 emergency disable mechanism preventing tools from being invoked. Provenance manifest \u2013 signed record (payload + hash + timestamp) proving what action occurred. Sigstore \u2013 open-source signing infrastructure; future target for production provenance. OTel (OpenTelemetry) \u2013 observability framework for traces/logs/metrics. Structlog \u2013 Python logging library producing structured logs.","title":"Glossary"},{"location":"governance/executive/","text":"Executive Brief Problem statement Enterprise agent stacks amplify productivity but expand the attack surface: - Tools proliferate without central inventory. - Policies and rate limits are inconsistent across vendors. - There is no provable audit trail tying actions to authorized identities. - Kill switches require bespoke scripts, creating MTTR risk. Sentinel MCP value Single source of truth for all MCP servers/skills with health, ownership, and scopes. Policy brain combining identity, tool metadata, purpose, and budgets via OPA. Kill-switch orchestration across AgentKit, LangGraph, Claude Skills, and custom adapters. Signed provenance for every action, supporting compliance and incident response. Adoption guide Day 0 \u2013 Discovery: inventory existing tools with the registry API; map owners and scopes. Day 1 \u2013 Policy pilot: deploy OPA bundles for a single business unit; monitor denies and adjust quotas. Day 2 \u2013 Enterprise rollout: integrate adapters across agent frameworks, enforce provenance mandates, and publish kill-switch runbook. Metrics to track % of tools inventoried vs estimated total. Policy violations caught and resolved (MTTR < 5 minutes goal). % of actions with verified provenance manifests. Kill-switch drill success rate (disabled + restored within SLA). Next steps Approve R&D spike for 2 weeks to productionize the prototype. Engage Platform Engineering and AppSec to co-own policy governance. Identify lighthouse teams (FinOps, Support) for co-design of policy templates.","title":"Executive Brief"},{"location":"governance/executive/#executive-brief","text":"","title":"Executive Brief"},{"location":"governance/executive/#problem-statement","text":"Enterprise agent stacks amplify productivity but expand the attack surface: - Tools proliferate without central inventory. - Policies and rate limits are inconsistent across vendors. - There is no provable audit trail tying actions to authorized identities. - Kill switches require bespoke scripts, creating MTTR risk.","title":"Problem statement"},{"location":"governance/executive/#sentinel-mcp-value","text":"Single source of truth for all MCP servers/skills with health, ownership, and scopes. Policy brain combining identity, tool metadata, purpose, and budgets via OPA. Kill-switch orchestration across AgentKit, LangGraph, Claude Skills, and custom adapters. Signed provenance for every action, supporting compliance and incident response.","title":"Sentinel MCP value"},{"location":"governance/executive/#adoption-guide","text":"Day 0 \u2013 Discovery: inventory existing tools with the registry API; map owners and scopes. Day 1 \u2013 Policy pilot: deploy OPA bundles for a single business unit; monitor denies and adjust quotas. Day 2 \u2013 Enterprise rollout: integrate adapters across agent frameworks, enforce provenance mandates, and publish kill-switch runbook.","title":"Adoption guide"},{"location":"governance/executive/#metrics-to-track","text":"% of tools inventoried vs estimated total. Policy violations caught and resolved (MTTR < 5 minutes goal). % of actions with verified provenance manifests. Kill-switch drill success rate (disabled + restored within SLA).","title":"Metrics to track"},{"location":"governance/executive/#next-steps","text":"Approve R&D spike for 2 weeks to productionize the prototype. Engage Platform Engineering and AppSec to co-own policy governance. Identify lighthouse teams (FinOps, Support) for co-design of policy templates.","title":"Next steps"},{"location":"governance/policy-playbook/","text":"Policy Playbook Core policy primitives Allow/Deny rules \u2013 map tenant + tool + purpose to permitted actions. Quotas \u2013 limit usage per tool/team (token count, invocations per minute). Scoped secrets \u2013 ensure tool credentials are only injected when policy allows (future integration with Vault). Kill overrides \u2013 emergency disable irrespective of policy (manual trigger or automated via detection systems). Sample policies (Rego snippets) package sentinel.policy default allow := false allow { allowed_tool within_quota purpose_ok } allowed_tool { data.allowlist[input.tenant][input.tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose == data.required_purpose[input.tenant][input.tool] } Playbook scenarios Scenario Policy action Follow-up Budget exceeded Deny, emit quota exceeded reason Notify FinOps, review quotas Unapproved purpose Deny, require ticket for new purpose Governance review Emergency disable Manual kill switch + audit log Incident response Tool onboarding Add to allowlist , define scopes, run seed script Owner sign-off Governance cadence Weekly policy review stand-up (Platform Eng + AppSec). Monthly metrics dashboard (violations, kills, provenance coverage). Quarterly tabletop exercise for kill-switch drills and provenance audits.","title":"Policy Playbook"},{"location":"governance/policy-playbook/#policy-playbook","text":"","title":"Policy Playbook"},{"location":"governance/policy-playbook/#core-policy-primitives","text":"Allow/Deny rules \u2013 map tenant + tool + purpose to permitted actions. Quotas \u2013 limit usage per tool/team (token count, invocations per minute). Scoped secrets \u2013 ensure tool credentials are only injected when policy allows (future integration with Vault). Kill overrides \u2013 emergency disable irrespective of policy (manual trigger or automated via detection systems).","title":"Core policy primitives"},{"location":"governance/policy-playbook/#sample-policies-rego-snippets","text":"package sentinel.policy default allow := false allow { allowed_tool within_quota purpose_ok } allowed_tool { data.allowlist[input.tenant][input.tool] } within_quota { input.usage < data.quotas[input.tenant][input.tool] } purpose_ok { input.purpose == data.required_purpose[input.tenant][input.tool] }","title":"Sample policies (Rego snippets)"},{"location":"governance/policy-playbook/#playbook-scenarios","text":"Scenario Policy action Follow-up Budget exceeded Deny, emit quota exceeded reason Notify FinOps, review quotas Unapproved purpose Deny, require ticket for new purpose Governance review Emergency disable Manual kill switch + audit log Incident response Tool onboarding Add to allowlist , define scopes, run seed script Owner sign-off","title":"Playbook scenarios"},{"location":"governance/policy-playbook/#governance-cadence","text":"Weekly policy review stand-up (Platform Eng + AppSec). Monthly metrics dashboard (violations, kills, provenance coverage). Quarterly tabletop exercise for kill-switch drills and provenance audits.","title":"Governance cadence"},{"location":"operations/runbooks/","text":"Operations Runbooks 1. Control plane health check fails Symptoms: /healthz returns non-200, agents report tool registry unavailable. docker compose ps (or orchestrator equivalent) \u2013 ensure control-plane/OPA/Postgres are running. Check structlog output for control_plane.startup errors. Run alembic current to verify database migrations. Re-run make seed to validate registry operations. If OPA unreachable, inspect opa container logs or policy bundle path. 2. Policy denies expected action Query recent policy log via database ( SELECT decision, reason FROM policy_logs ORDER BY created_at DESC LIMIT 10 ). Run pytest tests/unit/test_policy_route.py::test_policy_check_deny to ensure deny flow behaves. Verify OPA data ( opa eval --data opa/data.json --input <input.json> 'data.sentinel.policy' ). Update policies (Rego) and redeploy bundle. 3. Kill switch stuck (tool remains disabled) Check structlog events kill_switch.disabled and kill_switch.restored . Confirm adapters acknowledged disable (AgentKit logs, LangGraph middleware). Run curl /register?tenant_slug=... to confirm is_active status. Use /kill/restore endpoint or Admin UI enable button. If tool remains disabled, inspect adapter credentials and cached tokens; rotate secrets via Vault. 4. Provenance verification failure Use new manifest viewer ( npm run dev -> UI) or CLI: curl /provenance/verify/<id> . Compare manifest payload vs expected action; confirm timestamp/time skew. If signature mismatch, check signing key rotation; update .env SIGNING_KEY and redeploy. Consider re-signing using Sigstore when production signer introduced. 5. Seeding script fails Ensure stack is running: docker compose up -d . Seed script now waits for /healthz ; review logs for Control plane health check failed . Validate environment variables ( POSTGRES_PASSWORD , OPA_URL ). Run pytest tests/api/test_control_plane.py against live stack to reproduce. Escalation & notifications Structured logs: forward to SIEM/Observability stack to trigger alerts on kill_switch.* events. Add future webhook integration to notify Slack/PagerDuty on kill/restore operations. 6. Chaos drill (kill/restore) Ensure the stack is running ( ./scripts/dev_up.sh ). Execute ./scripts/chaos_kill.sh [options] <tenant> <tool> to simulate repeated kill/restore actions ( --cycles , --delay , --jitter , --log ). Monitor logs for kill_switch.disabled / kill_switch.restored and corresponding OTel spans. Verify tool state via /register?tenant_slug=... and the Admin console. Review provenance manifests and policy logs covering the drill window.","title":"Runbooks"},{"location":"operations/runbooks/#operations-runbooks","text":"","title":"Operations Runbooks"},{"location":"operations/runbooks/#1-control-plane-health-check-fails","text":"Symptoms: /healthz returns non-200, agents report tool registry unavailable. docker compose ps (or orchestrator equivalent) \u2013 ensure control-plane/OPA/Postgres are running. Check structlog output for control_plane.startup errors. Run alembic current to verify database migrations. Re-run make seed to validate registry operations. If OPA unreachable, inspect opa container logs or policy bundle path.","title":"1. Control plane health check fails"},{"location":"operations/runbooks/#2-policy-denies-expected-action","text":"Query recent policy log via database ( SELECT decision, reason FROM policy_logs ORDER BY created_at DESC LIMIT 10 ). Run pytest tests/unit/test_policy_route.py::test_policy_check_deny to ensure deny flow behaves. Verify OPA data ( opa eval --data opa/data.json --input <input.json> 'data.sentinel.policy' ). Update policies (Rego) and redeploy bundle.","title":"2. Policy denies expected action"},{"location":"operations/runbooks/#3-kill-switch-stuck-tool-remains-disabled","text":"Check structlog events kill_switch.disabled and kill_switch.restored . Confirm adapters acknowledged disable (AgentKit logs, LangGraph middleware). Run curl /register?tenant_slug=... to confirm is_active status. Use /kill/restore endpoint or Admin UI enable button. If tool remains disabled, inspect adapter credentials and cached tokens; rotate secrets via Vault.","title":"3. Kill switch stuck (tool remains disabled)"},{"location":"operations/runbooks/#4-provenance-verification-failure","text":"Use new manifest viewer ( npm run dev -> UI) or CLI: curl /provenance/verify/<id> . Compare manifest payload vs expected action; confirm timestamp/time skew. If signature mismatch, check signing key rotation; update .env SIGNING_KEY and redeploy. Consider re-signing using Sigstore when production signer introduced.","title":"4. Provenance verification failure"},{"location":"operations/runbooks/#5-seeding-script-fails","text":"Ensure stack is running: docker compose up -d . Seed script now waits for /healthz ; review logs for Control plane health check failed . Validate environment variables ( POSTGRES_PASSWORD , OPA_URL ). Run pytest tests/api/test_control_plane.py against live stack to reproduce.","title":"5. Seeding script fails"},{"location":"operations/runbooks/#escalation-notifications","text":"Structured logs: forward to SIEM/Observability stack to trigger alerts on kill_switch.* events. Add future webhook integration to notify Slack/PagerDuty on kill/restore operations.","title":"Escalation &amp; notifications"},{"location":"operations/runbooks/#6-chaos-drill-killrestore","text":"Ensure the stack is running ( ./scripts/dev_up.sh ). Execute ./scripts/chaos_kill.sh [options] <tenant> <tool> to simulate repeated kill/restore actions ( --cycles , --delay , --jitter , --log ). Monitor logs for kill_switch.disabled / kill_switch.restored and corresponding OTel spans. Verify tool state via /register?tenant_slug=... and the Admin console. Review provenance manifests and policy logs covering the drill window.","title":"6. Chaos drill (kill/restore)"},{"location":"operations/security/","text":"Security & Compliance Guidance Threat model highlights Unauthorized tool invocation: mitigated by policy enforcement at the control plane with deny-by-default rules and purpose checks. Compromised adapter credentials: kill-switch immediately disables tools and provenance manifests provide forensic trail. Policy bypass via prompt injection: guardrails sit between agent and tool, enforcing policies irrespective of prompt content. Provenance tampering: manifests are signed; move to Sigstore or KMS-backed signing for production. Controls in place Per-tool activation state ( is_active ) with rapid kill/restore flow. Rate/usage data captured in policy client (future: move to Redis counters for rate limiting). Structured logging with tenant/tool context for auditing. Signed manifests for every approved action (+ verification endpoint & UI). Recommended hardening Secrets management: move SIGNING_KEY , database credentials, and API tokens to Vault; rotate on a schedule. TLS everywhere: enforce TLS for OPA, Postgres, Redis; pin certificates in adapters. Sigstore integration: replace hash-only signer with sigstore library, store Rekor entries. OPA policy reviews: maintain policy-as-code repo with PR reviews and automated unit tests (rego, conftest). Dependency updates: rely on Dependabot/renovate; treat critical advisories as break-glass. Static analysis: add Bandit ( bandit -r apps/control-plane/src ) and ESLint security rules. Authentication/authorization: add API keys or OIDC tokens for control plane endpoints before production. Compliance pointers Audit logging: send kill_switch.* and policy decision logs to SIEM for retention & analytics. Data retention: configure Postgres retention policy for policy logs (e.g., 180 days) respecting privacy requirements. PII handling: tool metadata should avoid sensitive data; if necessary, pseudonymize owner fields. Access control: restrict who can trigger /kill and /kill/restore via RBAC (future feature). Incident response checklist Trigger kill-switch for impacted tool/tenant. Export provenance manifests for incident window. Audit policy logs for suspicious denies/allow events. Rotate secrets and redeploy adapters. Produce post-incident report using docs in Governance section.","title":"Security & Compliance"},{"location":"operations/security/#security-compliance-guidance","text":"","title":"Security &amp; Compliance Guidance"},{"location":"operations/security/#threat-model-highlights","text":"Unauthorized tool invocation: mitigated by policy enforcement at the control plane with deny-by-default rules and purpose checks. Compromised adapter credentials: kill-switch immediately disables tools and provenance manifests provide forensic trail. Policy bypass via prompt injection: guardrails sit between agent and tool, enforcing policies irrespective of prompt content. Provenance tampering: manifests are signed; move to Sigstore or KMS-backed signing for production.","title":"Threat model highlights"},{"location":"operations/security/#controls-in-place","text":"Per-tool activation state ( is_active ) with rapid kill/restore flow. Rate/usage data captured in policy client (future: move to Redis counters for rate limiting). Structured logging with tenant/tool context for auditing. Signed manifests for every approved action (+ verification endpoint & UI).","title":"Controls in place"},{"location":"operations/security/#recommended-hardening","text":"Secrets management: move SIGNING_KEY , database credentials, and API tokens to Vault; rotate on a schedule. TLS everywhere: enforce TLS for OPA, Postgres, Redis; pin certificates in adapters. Sigstore integration: replace hash-only signer with sigstore library, store Rekor entries. OPA policy reviews: maintain policy-as-code repo with PR reviews and automated unit tests (rego, conftest). Dependency updates: rely on Dependabot/renovate; treat critical advisories as break-glass. Static analysis: add Bandit ( bandit -r apps/control-plane/src ) and ESLint security rules. Authentication/authorization: add API keys or OIDC tokens for control plane endpoints before production.","title":"Recommended hardening"},{"location":"operations/security/#compliance-pointers","text":"Audit logging: send kill_switch.* and policy decision logs to SIEM for retention & analytics. Data retention: configure Postgres retention policy for policy logs (e.g., 180 days) respecting privacy requirements. PII handling: tool metadata should avoid sensitive data; if necessary, pseudonymize owner fields. Access control: restrict who can trigger /kill and /kill/restore via RBAC (future feature).","title":"Compliance pointers"},{"location":"operations/security/#incident-response-checklist","text":"Trigger kill-switch for impacted tool/tenant. Export provenance manifests for incident window. Audit policy logs for suspicious denies/allow events. Rotate secrets and redeploy adapters. Produce post-incident report using docs in Governance section.","title":"Incident response checklist"},{"location":"technical/architecture/","text":"Architecture Deep Dive High-level flow Agents & adapters (AgentKit, LangGraph, Claude Skills) register with Sentinel MCP, sending tool metadata and health. Control plane (FastAPI) persists tenants, tools, and policy logs in Postgres, caches rate data in Redis, and proxies policy requests to OPA. Policy engine (OPA) evaluates Rego policies using tenant/tool context, quota counters, and purpose metadata, returning allow/deny along with reasoning. Kill-switch orchestration updates tool state, revokes credentials via adapter hooks, and emits structured logs with OpenTelemetry spans. Provenance signer emits a signed manifest (Sigstore-compatible stub today) for every approved action and exposes verification endpoints + UI widget. Components Component Technology Responsibility Control plane API FastAPI, SQLAlchemy Tool registry, policy evaluation proxy, kill/restore orchestration, provenance endpoints Database Postgres Tenants, tools, policy audit logs Cache / queues Redis Future rate limiting queues, kill broadcasts Policy engine OPA sidecar Evaluates Rego policies (allow/deny, quota enforcement, scoped secrets) Provenance services Custom module Hash/sign manifests, provide verification Admin console Next.js + React Inventory UI, kill switch controls, policy probes, manifest viewer Tests Pytest, Vitest Unit, integration, UI smoke tests Telemetry Structured logs provided via Structlog ( kill_switch.disabled/restored ). OpenTelemetry spans wrap kill/restore handlers with tenant/tool metadata; extendable to policy/provenance routes. Future work: export OTLP traces to an APM (Tempo, Honeycomb) and ship logs to a SIEM. Data model snapshot Tenant : id , slug , display_name , created_at . Tool : id , tenant_id , name , url , owner , scopes , extra_metadata , is_active , timestamps. PolicyLog : id , tenant_id , tool_id , decision , reason , event_metadata , timestamps. Sequence: tool invocation dialogue participant Agent participant Adapter participant ControlPlane participant OPA participant Provenance Agent->>Adapter: Invoke tool Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy (tenant/tool context) OPA-->>ControlPlane: Allow + quota remaining ControlPlane-->>Adapter: Allow Adapter->>Agent: Continue execution Adapter->>ControlPlane: POST /provenance/sign ControlPlane->>Provenance: Sign manifest (hash + store) Provenance-->>Adapter: Manifest id (If policy denies, the adapter gets the reason and blocks the tool.) Deployment modes Local dev : docker-compose.dev.yml spins Postgres, Redis, OPA, control plane, admin console. Staging/prod : use Terraform modules under infra/terraform (stub today) targeting managed Postgres, Redis, HashiCorp Vault, and container orchestrator (ECS/Kubernetes). OPA sidecar can be co-located per control plane pod.","title":"Architecture"},{"location":"technical/architecture/#architecture-deep-dive","text":"","title":"Architecture Deep Dive"},{"location":"technical/architecture/#high-level-flow","text":"Agents & adapters (AgentKit, LangGraph, Claude Skills) register with Sentinel MCP, sending tool metadata and health. Control plane (FastAPI) persists tenants, tools, and policy logs in Postgres, caches rate data in Redis, and proxies policy requests to OPA. Policy engine (OPA) evaluates Rego policies using tenant/tool context, quota counters, and purpose metadata, returning allow/deny along with reasoning. Kill-switch orchestration updates tool state, revokes credentials via adapter hooks, and emits structured logs with OpenTelemetry spans. Provenance signer emits a signed manifest (Sigstore-compatible stub today) for every approved action and exposes verification endpoints + UI widget.","title":"High-level flow"},{"location":"technical/architecture/#components","text":"Component Technology Responsibility Control plane API FastAPI, SQLAlchemy Tool registry, policy evaluation proxy, kill/restore orchestration, provenance endpoints Database Postgres Tenants, tools, policy audit logs Cache / queues Redis Future rate limiting queues, kill broadcasts Policy engine OPA sidecar Evaluates Rego policies (allow/deny, quota enforcement, scoped secrets) Provenance services Custom module Hash/sign manifests, provide verification Admin console Next.js + React Inventory UI, kill switch controls, policy probes, manifest viewer Tests Pytest, Vitest Unit, integration, UI smoke tests","title":"Components"},{"location":"technical/architecture/#telemetry","text":"Structured logs provided via Structlog ( kill_switch.disabled/restored ). OpenTelemetry spans wrap kill/restore handlers with tenant/tool metadata; extendable to policy/provenance routes. Future work: export OTLP traces to an APM (Tempo, Honeycomb) and ship logs to a SIEM.","title":"Telemetry"},{"location":"technical/architecture/#data-model-snapshot","text":"Tenant : id , slug , display_name , created_at . Tool : id , tenant_id , name , url , owner , scopes , extra_metadata , is_active , timestamps. PolicyLog : id , tenant_id , tool_id , decision , reason , event_metadata , timestamps.","title":"Data model snapshot"},{"location":"technical/architecture/#sequence-tool-invocation","text":"dialogue participant Agent participant Adapter participant ControlPlane participant OPA participant Provenance Agent->>Adapter: Invoke tool Adapter->>ControlPlane: POST /policy/check ControlPlane->>OPA: Evaluate policy (tenant/tool context) OPA-->>ControlPlane: Allow + quota remaining ControlPlane-->>Adapter: Allow Adapter->>Agent: Continue execution Adapter->>ControlPlane: POST /provenance/sign ControlPlane->>Provenance: Sign manifest (hash + store) Provenance-->>Adapter: Manifest id (If policy denies, the adapter gets the reason and blocks the tool.)","title":"Sequence: tool invocation"},{"location":"technical/architecture/#deployment-modes","text":"Local dev : docker-compose.dev.yml spins Postgres, Redis, OPA, control plane, admin console. Staging/prod : use Terraform modules under infra/terraform (stub today) targeting managed Postgres, Redis, HashiCorp Vault, and container orchestrator (ECS/Kubernetes). OPA sidecar can be co-located per control plane pod.","title":"Deployment modes"},{"location":"technical/setup/","text":"Setup & Deployment Prerequisites Python 3.11+ Node 20+ Docker Desktop (or compatible engine) for local compose mkdocs (optional) for building docs: pip install mkdocs Local development Clone and bootstrap bash git clone <repo> cd sentinel-mcp cp .env.example .env # update POSTGRES_PASSWORD, SIGNING_KEY, etc. make install source .venv/bin/activate pytest cd apps/admin-console && npm install && npm run lint && npm run test Bring up the stack bash docker compose -f docker-compose.dev.yml up -d docker compose -f docker-compose.dev.yml exec control-plane alembic upgrade head source ../.venv/bin/activate && make seed Explore the UI bash NEXT_PUBLIC_CONTROL_PLANE_URL=http://localhost:8000 npm run dev Inventory tools, trigger kill switch, re-enable via restore, and verify manifests. Tear down bash docker compose -f docker-compose.dev.yml down Running tests Backend unit + integration: pytest API smoke against live control plane: pytest -m e2e (future marker). Frontend: npm run lint && npm run test Docs: mkdocs serve (live preview) or mkdocs build (static output). CI recommendations Lint & format: pre-commit run --all-files Python matrix: pytest with sqlite fallback + docker-compose integration job. Frontend job: install, lint, vitest. Docs job: pip install mkdocs-material then mkdocs build . Security job: pip install bandit and run bandit -r apps/control-plane/src plus npm audit --production . Deployment outline Infrastructure : provision Postgres (with TLS), Redis, Vault or Secrets Manager, and an OPA deployment. Control plane : build container via docker build -f apps/control-plane/Dockerfile . , push to registry. OPA policies : mount Rego bundles via bucket or GitOps. Admin console : build static site ( npm run build ) and host behind CDN. Observability : configure OTLP exporter and structure logs to a centralized log pipeline. Secrets : supply environment variables via Vault injectors or orchestrator secrets. Kill/restore notifications : integrate with Slack/PagerDuty via webhook triggered from Structlog processor or event stream (future work).","title":"Setup & Deployment"},{"location":"technical/setup/#setup-deployment","text":"","title":"Setup &amp; Deployment"},{"location":"technical/setup/#prerequisites","text":"Python 3.11+ Node 20+ Docker Desktop (or compatible engine) for local compose mkdocs (optional) for building docs: pip install mkdocs","title":"Prerequisites"},{"location":"technical/setup/#local-development","text":"Clone and bootstrap bash git clone <repo> cd sentinel-mcp cp .env.example .env # update POSTGRES_PASSWORD, SIGNING_KEY, etc. make install source .venv/bin/activate pytest cd apps/admin-console && npm install && npm run lint && npm run test Bring up the stack bash docker compose -f docker-compose.dev.yml up -d docker compose -f docker-compose.dev.yml exec control-plane alembic upgrade head source ../.venv/bin/activate && make seed Explore the UI bash NEXT_PUBLIC_CONTROL_PLANE_URL=http://localhost:8000 npm run dev Inventory tools, trigger kill switch, re-enable via restore, and verify manifests. Tear down bash docker compose -f docker-compose.dev.yml down","title":"Local development"},{"location":"technical/setup/#running-tests","text":"Backend unit + integration: pytest API smoke against live control plane: pytest -m e2e (future marker). Frontend: npm run lint && npm run test Docs: mkdocs serve (live preview) or mkdocs build (static output).","title":"Running tests"},{"location":"technical/setup/#ci-recommendations","text":"Lint & format: pre-commit run --all-files Python matrix: pytest with sqlite fallback + docker-compose integration job. Frontend job: install, lint, vitest. Docs job: pip install mkdocs-material then mkdocs build . Security job: pip install bandit and run bandit -r apps/control-plane/src plus npm audit --production .","title":"CI recommendations"},{"location":"technical/setup/#deployment-outline","text":"Infrastructure : provision Postgres (with TLS), Redis, Vault or Secrets Manager, and an OPA deployment. Control plane : build container via docker build -f apps/control-plane/Dockerfile . , push to registry. OPA policies : mount Rego bundles via bucket or GitOps. Admin console : build static site ( npm run build ) and host behind CDN. Observability : configure OTLP exporter and structure logs to a centralized log pipeline. Secrets : supply environment variables via Vault injectors or orchestrator secrets. Kill/restore notifications : integrate with Slack/PagerDuty via webhook triggered from Structlog processor or event stream (future work).","title":"Deployment outline"},{"location":"technical/testing/","text":"Testing Strategy Layers Layer Tooling Coverage Unit Pytest, Vitest Business logic, policy client stubs, UI components API Pytest TestClient Policy allow/deny, kill/restore responses Integration (opt-in) docker-compose End-to-end health, seeding, provenance verification UI smoke Vitest + Testing Library (future: Playwright) Kill/restore toggle, manifest verification Chaos (future) custom scripts OPA outage, rate-limit spikes, kill-switch drills Current suites tests/unit/test_policy_client.py : OPA client happy/error paths. tests/unit/test_policy_route.py : allow/deny behaviour without live OPA. tests/unit/test_provenance.py : sign/verify round-trip. tests/unit/test_agentkit_adapter.py : adapter enforces allow before provenance. tests/api/test_control_plane.py : end-to-end register \u2192 policy \u2192 kill/restore \u2192 provenance (skips if control plane not running). Admin console: ToolTable and ManifestViewer components. Recommended additions Database constraint tests (unique tool names, tenant slug case sensitivity). Chaos harness verifying kill-switch MTTR and quota exhaustion. UI e2e using Playwright to exercise full flows. Testing commands source .venv/bin/activate pytest pytest tests/api/test_control_plane.py # requires stack running cd apps/admin-console npm run lint npm run test Quality gates Branch protection should require backend lint/tests ( pytest ) and frontend lint/tests ( npm run lint && npm run test ). Nightly integration pipeline ( .github/workflows/nightly-e2e.yml ) spins up the compose stack, seeds, and runs the API smoke suite. Dependabot updates must include test runs before merge. Chaos drills Script: ./scripts/chaos_kill.sh [--cycles N] [--delay N] [--jitter N] [--log FILE] <tenant_slug> <tool_name> for quick kill/restore loops. Track structured logs and spans to ensure kill MTTR < 5 seconds. Extend with rate-limit spikes and OPA outage simulations (future).","title":"Testing Strategy"},{"location":"technical/testing/#testing-strategy","text":"","title":"Testing Strategy"},{"location":"technical/testing/#layers","text":"Layer Tooling Coverage Unit Pytest, Vitest Business logic, policy client stubs, UI components API Pytest TestClient Policy allow/deny, kill/restore responses Integration (opt-in) docker-compose End-to-end health, seeding, provenance verification UI smoke Vitest + Testing Library (future: Playwright) Kill/restore toggle, manifest verification Chaos (future) custom scripts OPA outage, rate-limit spikes, kill-switch drills","title":"Layers"},{"location":"technical/testing/#current-suites","text":"tests/unit/test_policy_client.py : OPA client happy/error paths. tests/unit/test_policy_route.py : allow/deny behaviour without live OPA. tests/unit/test_provenance.py : sign/verify round-trip. tests/unit/test_agentkit_adapter.py : adapter enforces allow before provenance. tests/api/test_control_plane.py : end-to-end register \u2192 policy \u2192 kill/restore \u2192 provenance (skips if control plane not running). Admin console: ToolTable and ManifestViewer components.","title":"Current suites"},{"location":"technical/testing/#recommended-additions","text":"Database constraint tests (unique tool names, tenant slug case sensitivity). Chaos harness verifying kill-switch MTTR and quota exhaustion. UI e2e using Playwright to exercise full flows.","title":"Recommended additions"},{"location":"technical/testing/#testing-commands","text":"source .venv/bin/activate pytest pytest tests/api/test_control_plane.py # requires stack running cd apps/admin-console npm run lint npm run test","title":"Testing commands"},{"location":"technical/testing/#quality-gates","text":"Branch protection should require backend lint/tests ( pytest ) and frontend lint/tests ( npm run lint && npm run test ). Nightly integration pipeline ( .github/workflows/nightly-e2e.yml ) spins up the compose stack, seeds, and runs the API smoke suite. Dependabot updates must include test runs before merge.","title":"Quality gates"},{"location":"technical/testing/#chaos-drills","text":"Script: ./scripts/chaos_kill.sh [--cycles N] [--delay N] [--jitter N] [--log FILE] <tenant_slug> <tool_name> for quick kill/restore loops. Track structured logs and spans to ensure kill MTTR < 5 seconds. Extend with rate-limit spikes and OPA outage simulations (future).","title":"Chaos drills"}]}